<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="referrer" content="no-referrer">
    <title>假新闻检测系统</title>
    <link rel="icon" href="/ico/Detect.ico">
    <script src="/js/theme-loader.js"></script>
</head>

<body>
    <div id="title-bar">
        <div class="app-icon"></div>
        <button class="sidebar-toggle-btn" id="sidebarToggleBtn" title="展开/收起">
            <!-- Dock To Right (Expand) -->
            <svg class="icon-expand" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M4.75 4A2.75 2.75 0 0 0 2 6.75v10.5A2.75 2.75 0 0 0 4.75 20h14.5A2.75 2.75 0 0 0 22 17.25V6.75A2.75 2.75 0 0 0 19.25 4H4.75ZM3.5 6.75c0-.69.56-1.25 1.25-1.25h3.254v13H4.75c-.69 0-1.25-.56-1.25-1.25V6.75ZM9.504 18.5v-13h9.746c.69 0 1.25.56 1.25 1.25v10.5c0 .69-.56 1.25-1.25 1.25H9.504Z" />
            </svg>
            <!-- Dock To Left (Collapse) -->
            <svg class="icon-collapse" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M19.25 4A2.75 2.75 0 0 1 22 6.75v10.5A2.75 2.75 0 0 1 19.25 20H4.75A2.75 2.75 0 0 1 2 17.25V6.75A2.75 2.75 0 0 1 4.75 4h14.5Zm1.25 2.75c0-.69-.56-1.25-1.25-1.25h-3.254v13h3.254c.69 0 1.25-.56 1.25-1.25V6.75ZM14.496 18.5v-13H4.75c-.69 0-1.25.56-1.25 1.25v10.5c0 .69.56 1.25 1.25 1.25h9.746Z" />
            </svg>
        </button>
        <button class="sidebar-toggle-btn" id="previewBtn" title="页面预览" style="margin-left: 4px;">
            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M12 9.005a4 4 0 1 1 0 8 4 4 0 0 1 0-8Zm0 1.5a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5ZM12 5.5c4.613 0 8.596 3.15 9.701 7.564a.75.75 0 1 1-1.455.365 8.503 8.503 0 0 0-16.493.004.75.75 0 0 1-1.455-.363A10.003 10.003 0 0 1 12 5.5Z" />
            </svg>
        </button>
        <!-- Batch Mode Toggle -->
        <div class="batch-mode-toggle" id="batchModeToggle" title="批量处理模式">
            <svg class="batch-icon" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                <path d="M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z" />
            </svg>
            <div class="toggle-switch"></div>
        </div>

        <div class="title-bar-actions">
            <button class="toolbar-btn" id="themeBtn" title="切换主题">
                <svg id="themeIconLight" width="22" height="22" viewBox="0 0 24 24" fill="currentColor"
                    style="display: none;">
                    <path
                        d="M20.026 17.001c-2.762 4.784-8.879 6.423-13.663 3.661a9.964 9.964 0 0 1-3.234-2.983.75.75 0 0 1 .365-1.131c3.767-1.348 5.785-2.911 6.956-5.146 1.232-2.353 1.551-4.93.689-8.464a.75.75 0 0 1 .769-.926 9.961 9.961 0 0 1 4.457 1.327C21.149 6.1 22.788 12.217 20.025 17Zm-8.248-4.903c-1.25 2.388-3.31 4.099-6.817 5.499a8.492 8.492 0 0 0 2.152 1.766 8.501 8.501 0 1 0 8.502-14.725 8.485 8.485 0 0 0-2.792-1.016c.647 3.384.23 6.044-1.045 8.476Z" />
                </svg>
                <svg id="themeIconDark" width="22" height="22" viewBox="0 0 24 24" fill="currentColor"
                    style="display: none;">
                    <path
                        d="M11.996 19.01a.75.75 0 0 1 .743.649l.007.102v1.5a.75.75 0 0 1-1.493.101l-.007-.101v-1.5a.75.75 0 0 1 .75-.75Zm6.022-2.072 1.06 1.06a.75.75 0 1 1-1.06 1.061l-1.06-1.06a.75.75 0 0 1 1.06-1.061Zm-10.983 0a.75.75 0 0 1 0 1.06L5.974 19.06a.75.75 0 0 1-1.06-1.06l1.06-1.061a.75.75 0 0 1 1.06 0ZM12 6.475a5.525 5.525 0 1 1 0 11.05 5.525 5.525 0 0 1 0-11.05Zm0 1.5a4.025 4.025 0 1 0 0 8.05 4.025 4.025 0 0 0 0-8.05Zm9.25 3.293a.75.75 0 0 1 .102 1.493l-.102.007h-1.5a.75.75 0 0 1-.102-1.493l.102-.007h1.5Zm-17-.029a.75.75 0 0 1 .102 1.494l-.102.006h-1.5a.75.75 0 0 1-.102-1.493l.102-.007h1.5Zm1.64-6.37.084.072 1.06 1.06a.75.75 0 0 1-.976 1.134l-.084-.073-1.06-1.06a.75.75 0 0 1 .976-1.134Zm13.188.072a.75.75 0 0 1 .073.977l-.073.084-1.06 1.06a.75.75 0 0 1-1.133-.976l.072-.084 1.06-1.061a.75.75 0 0 1 1.061 0ZM12 1.99a.75.75 0 0 1 .743.648l.007.102v1.5a.75.75 0 0 1-1.493.101l-.007-.102v-1.5a.75.75 0 0 1 .75-.75Z" />
                </svg>
            </button>
            <div class="toolbar-btn more-menu" id="moreBtn" title="设置" tabindex="0">
                <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                    <path
                        d="M12.012 2.25c.734.008 1.465.093 2.182.253a.75.75 0 0 1 .582.649l.17 1.527a1.384 1.384 0 0 0 1.927 1.116l1.401-.615a.75.75 0 0 1 .85.174 9.792 9.792 0 0 1 2.204 3.792.75.75 0 0 1-.271.825l-1.242.916a1.381 1.381 0 0 0 0 2.226l1.243.915a.75.75 0 0 1 .272.826 9.797 9.797 0 0 1-2.204 3.792.75.75 0 0 1-.848.175l-1.407-.617a1.38 1.38 0 0 0-1.926 1.114l-.169 1.526a.75.75 0 0 1-.572.647 9.518 9.518 0 0 1-4.406 0 .75.75 0 0 1-.572-.647l-.168-1.524a1.382 1.382 0 0 0-1.926-1.11l-1.406.616a.75.75 0 0 1-.849-.175 9.798 9.798 0 0 1-2.204-3.796.75.75 0 0 1 .272-.826l1.243-.916a1.38 1.38 0 0 0 0-2.226l-1.243-.914a.75.75 0 0 1-.271-.826 9.793 9.793 0 0 1 2.204-3.792.75.75 0 0 1 .85-.174l1.4.615a1.387 1.387 0 0 0 1.93-1.118l.17-1.526a.75.75 0 0 1 .583-.65c.717-.159 1.45-.243 2.201-.252Zm0 1.5a9.135 9.135 0 0 0-1.354.117l-.109.977A2.886 2.886 0 0 1 6.525 7.17l-.898-.394a8.293 8.293 0 0 0-1.348 2.317l.798.587a2.881 2.881 0 0 1 0 4.643l-.799.588c.32.842.776 1.626 1.348 2.322l.905-.397a2.882 2.882 0 0 1 4.017 2.318l.11.984c.889.15 1.798.15 2.687 0l.11-.984a2.881 2.881 0 0 1 4.018-2.322l.905.396a8.296 8.296 0 0 0 1.347-2.318l-.798-.588a2.881 2.881 0 0 1 0-4.643l.796-.587a8.293 8.293 0 0 0-1.348-2.317l-.896.393a2.884 2.884 0 0 1-4.023-2.324l-.11-.976a8.988 8.988 0 0 0-1.333-.117ZM12 8.25a3.75 3.75 0 1 1 0 7.5 3.75 3.75 0 0 1 0-7.5Zm0 1.5a2.25 2.25 0 1 0 0 4.5 2.25 2.25 0 0 0 0-4.5Z" />
                </svg>
                <div class="dropdown-menu" id="moreDropdown">
                    <div class="dropdown-item-row" id="colorPaletteRow"
                        style="padding: 10px 16px; flex-direction: column; align-items: stretch; gap: 8px;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3.839 5.858c2.94-3.916 9.03-5.055 13.364-2.36 4.28 2.66 5.854 7.777 4.1 12.577-1.655 4.533-6.016 6.328-9.159 4.048-1.177-.854-1.634-1.925-1.854-3.664l-.106-.987-.045-.398c-.123-.934-.311-1.352-.705-1.572-.535-.298-.892-.305-1.595-.033l-.351.146-.179.078c-1.014.44-1.688.595-2.541.416l-.2-.047-.164-.047c-2.789-.864-3.202-4.647-.565-8.157Zm.984 6.716.123.037.134.03c.439.087.814.015 1.437-.242l.602-.257c1.202-.493 1.985-.54 3.046.05.917.512 1.275 1.298 1.457 2.66l.053.459.055.532.047.422c.172 1.361.485 2.09 1.248 2.644 2.275 1.65 5.534.309 6.87-3.349 1.516-4.152.174-8.514-3.484-10.789-3.675-2.284-8.899-1.306-11.373 1.987-2.075 2.763-1.82 5.28-.215 5.816Zm11.225-1.994a1.25 1.25 0 1 1 2.414-.647 1.25 1.25 0 0 1-2.414.647Zm.494 3.488a1.25 1.25 0 1 1 2.415-.647 1.25 1.25 0 0 1-2.415.647ZM14.07 7.577a1.25 1.25 0 1 1 2.415-.647 1.25 1.25 0 0 1-2.415.647Zm-.028 8.998a1.25 1.25 0 1 1 2.414-.647 1.25 1.25 0 0 1-2.414.647Zm-3.497-9.97a1.25 1.25 0 1 1 2.415-.646 1.25 1.25 0 0 1-2.415.646Z" />
                            </svg>
                            <span>颜色主题</span>
                        </div>
                        <div class="color-palette-row" id="colorPaletteContainer">
                        </div>
                    </div>
                    <div class="dropdown-separator"></div>

                    <div class="dropdown-item-row">
                        <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M10.212 17.11 15.043 3.5c.223-.627 1.07-.664 1.365-.111l.049.11 5.5 15.5a.75.75 0 0 1-1.373.596l-.04-.094L18.945 15h-6.394l-1.58 4.452a.75.75 0 0 1-.354.452l-.093.044a.75.75 0 0 1-.929-.33l-.044-.092L8.556 17H4.443l-.995 2.52a.75.75 0 0 1-.876.454l-.098-.031a.75.75 0 0 1-.452-.876l.03-.098 3.754-9.495c.236-.595 1.043-.63 1.345-.104l.05.105 3.011 7.635L15.043 3.5l-4.831 13.61Zm-3.71-5.318L5.037 15.5h2.928l-1.461-3.708Zm9.248-5.8L13.084 13.5h5.33L15.75 5.992Z" />
                        </svg>
                        <span>字体缩放</span>
                        <div class="zoom-controls">
                            <button class="zoom-btn" id="fontDec">-</button>
                            <span class="zoom-val" id="fontVal">1.0</span>
                            <button class="zoom-btn" id="fontInc">+</button>
                        </div>
                    </div>
                </div>
            </div>
            <button class="toolbar-btn" id="fullScreenBtn" title="全屏显示">
                <svg class="icon-enter-fullscreen" width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                    <path
                        d="M4.5 5.75c0-.69.56-1.25 1.25-1.25h2a.75.75 0 0 0 0-1.5h-2A2.75 2.75 0 0 0 3 5.75v2a.75.75 0 0 0 1.5 0v-2ZM4.5 18.25c0 .69.56 1.25 1.25 1.25h2a.75.75 0 0 1 0 1.5h-2A2.75 2.75 0 0 1 3 18.25v-2a.75.75 0 0 1 1.5 0v2ZM18.25 4.5c.69 0 1.25.56 1.25 1.25v2a.75.75 0 0 0 1.5 0v-2A2.75 2.75 0 0 0 18.25 3h-2a.75.75 0 0 0 0 1.5h2ZM19.5 18.25c0 .69-.56 1.25-1.25 1.25h-2a.75.75 0 0 0 0 1.5h2A2.75 2.75 0 0 0 21 18.25v-2a.75.75 0 0 0-1.5 0v2Z" />
                </svg>
                <svg class="icon-exit-fullscreen" width="22" height="22" viewBox="0 0 24 24" fill="currentColor"
                    style="display: none;">
                    <path
                        d="M8.5 3.75a.75.75 0 0 0-1.5 0v2.5a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 0 0 1.5h2.5A2.25 2.25 0 0 0 8.5 6.25v-2.5ZM8.5 20.25a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 0-.75-.75h-2.5a.75.75 0 0 1 0-1.5h2.5a2.25 2.25 0 0 1 2.25 2.25v2.5ZM16.25 3a.75.75 0 0 0-.75.75v2.5a2.25 2.25 0 0 0 2.25 2.25h2.5a.75.75 0 0 0 0-1.5h-2.5a.75.75 0 0 1-.75-.75v-2.5a.75.75 0 0 0-.75-.75ZM15.5 20.25a.75.75 0 0 0 1.5 0v-2.5a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 0 0-1.5h-2.5a2.25 2.25 0 0 0-2.25 2.25v2.5Z" />
                </svg>
            </button>
            <!-- User Profile Menu -->
            <div class="toolbar-btn more-menu" id="userBtn" title="个人中心" tabindex="0" style="margin-left: 2px;">
                <img id="topBarAvatar" src="" style="display:none;">
                <svg id="topBarUserIcon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                    stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                    <circle cx="12" cy="7" r="4"></circle>
                </svg>
                <div class="dropdown-menu" id="userDropdown">
                    <div class="dropdown-header" id="usernameDisplay"
                        style="padding: 10px 15px; font-weight: 600; font-size: 14px; border-bottom: 1px solid var(--border-color); margin-bottom: 5px;">
                        Loading...
                    </div>
                    <div class="dropdown-item" id="changeAvatarBtn">
                        <div class="dropdown-item-icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                                <circle cx="12" cy="7" r="4"></circle>
                            </svg>
                        </div>
                        <span>修改用户信息</span>
                    </div>
                    <div class="dropdown-item" id="adminBtn" style="display: none;">
                        <div class="dropdown-item-icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
                                <path d="M12 8v4"></path>
                                <line x1="12" y1="16" x2="12.01" y2="16"></line>
                            </svg>
                        </div>
                        <span>进入后台管理</span>
                    </div>
                    <div class="dropdown-item" id="logoutBtn">
                        <div class="dropdown-item-icon">
                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                                <polyline points="16 17 21 12 16 7"></polyline>
                                <line x1="21" y1="12" x2="9" y2="12"></line>
                            </svg>
                        </div>
                        <span>退出登录</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <input type="file" id="fileInput" multiple accept="image/*,.heic,.heif" style="display: none;">
    <input type="file" id="avatarInput" accept="image/*,.heic,.heif" style="display: none;">
    <div class="container">
        <div class="left-sidebar" id="leftSidebar">
            <!-- 工具栏 -->
            <div class="toolbar">
                <!-- Exit Batch Edit Button -->
                <button class="toolbar-btn" id="batchExitBtn" title="返回列表" style="display: none;">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" />
                    </svg>
                    <span class="btn-label">返回列表</span>
                </button>

                <button class="toolbar-btn" id="newChatBtn" title="新对话">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M12 2c5.523 0 10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2Zm0 1.5a8.5 8.5 0 1 0 0 17 8.5 8.5 0 0 0 0-17ZM12 7a.75.75 0 0 1 .75.75v3.5h3.5a.75.75 0 0 1 0 1.5h-3.5v3.5a.75.75 0 0 1-1.5 0v-3.5h-3.5a.75.75 0 0 1 0-1.5h3.5v-3.5A.75.75 0 0 1 12 7Z" />
                    </svg>
                    <span class="btn-label">新对话</span>
                </button>
                <button class="toolbar-btn" id="editBtn" title="编辑模式">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M21.03 2.97a3.578 3.578 0 0 1 0 5.06L9.062 20a2.25 2.25 0 0 1-.999.58l-5.116 1.395a.75.75 0 0 1-.92-.921l1.395-5.116a2.25 2.25 0 0 1 .58-.999L15.97 2.97a3.578 3.578 0 0 1 5.06 0ZM15 6.06 5.062 16a.75.75 0 0 0-.193.333l-1.05 3.85 3.85-1.05A.75.75 0 0 0 8 18.938L17.94 9 15 6.06Zm2.03-2.03-.97.97L19 7.94l.97-.97a2.079 2.079 0 0 0-2.94-2.94Z" />
                    </svg>
                    <span class="btn-label">编辑模式</span>
                </button>
                <button class="toolbar-btn" id="imageBtn" title="添加图片">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M17.75 3A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75V6.25A3.25 3.25 0 0 1 6.25 3h11.5Zm.58 16.401-5.805-5.686a.75.75 0 0 0-.966-.071l-.084.07-5.807 5.687c.182.064.378.099.582.099h11.5c.203 0 .399-.035.58-.099l-5.805-5.686L18.33 19.4ZM17.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v11.5c0 .208.036.408.103.594l5.823-5.701a2.25 2.25 0 0 1 3.02-.116l.128.116 5.822 5.702c.067-.186.104-.386.104-.595V6.25a1.75 1.75 0 0 0-1.75-1.75Zm-2.498 2a2.252 2.252 0 1 1 0 4.504 2.252 2.252 0 0 1 0-4.504Zm0 1.5a.752.752 0 1 0 0 1.504.752.752 0 0 0 0-1.504Z" />
                    </svg>
                    <span class="btn-label">添加图片</span>
                </button>
                <button class="toolbar-btn" id="importFileBtn" title="导入文件">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M18 20.5C18.276 20.5 18.5 20.275 18.5 20V10H14C12.896 10 12 9.104 12 8V3.5H6C5.724 3.5 5.5 3.725 5.5 4V14H4.75C4.4948 14 4.2443 14.0201 4 14.0589V4C4 2.896 4.896 2 6 2H12.172C12.6865 2 13.2194 2.22035 13.585 2.586L19.414 8.414C19.789 8.789 20 9.298 20 9.828V20C20 21.104 19.104 22 18 22H11.7141C12.1196 21.568 12.4451 21.0601 12.6672 20.5H18ZM17.378 8.5L13.5 4.621V8C13.5 8.275 13.724 8.5 14 8.5H17.378ZM9.77472 14.25C10.6292 14.5394 11.3746 15.0654 11.9329 15.75H15.25C15.6642 15.75 16 15.4142 16 15C16 14.5858 15.6642 14.25 15.25 14.25H9.77472ZM12.6672 17C12.8528 17.4681 12.9662 17.9727 12.9935 18.5H15.25C15.6642 18.5 16 18.1642 16 17.75C16 17.3358 15.6642 17 15.25 17H12.6672ZM8.75 11.5C8.33579 11.5 8 11.8358 8 12.25C8 12.6642 8.33579 13 8.75 13H15.25C15.6642 13 16 12.6642 16 12.25C16 11.8358 15.6642 11.5 15.25 11.5H8.75ZM12 18.75C12 16.6789 10.3211 15 8.25 15L8.14823 15.0068C7.78215 15.0565 7.49997 15.3703 7.49997 15.75C7.49997 16.1642 7.83579 16.5 8.25 16.5L8.40405 16.5052C9.57484 16.5844 10.5 17.5591 10.5 18.75C10.5 19.9926 9.49264 21 8.25 21L8.24656 21.0046L8.14482 21.0119C7.77898 21.0633 7.49826 21.3783 7.49997 21.758C7.50191 22.1722 7.83923 22.5065 8.25344 22.5046V22.5L8.45228 22.4948C10.4276 22.3913 12 20.7543 12 18.75ZM5.5 15.75C5.5 15.3358 5.16421 15 4.75 15L4.55084 15.0052C2.57236 15.1087 1 16.7457 1 18.75C1 20.8211 2.67893 22.5 4.75 22.5L4.85177 22.4932C5.21785 22.4435 5.5 22.1297 5.5 21.75C5.5 21.3358 5.16421 21 4.75 21L4.59595 20.9948C3.42516 20.9156 2.5 19.9409 2.5 18.75C2.5 17.5074 3.50736 16.5 4.75 16.5L4.85177 16.4932C5.21785 16.4435 5.5 16.1297 5.5 15.75ZM9 18.75C9 18.3358 8.66421 18 8.25 18H4.75L4.64823 18.0068C4.28215 18.0565 4 18.3703 4 18.75C4 19.1642 4.33579 19.5 4.75 19.5H8.25L8.35177 19.4932C8.71785 19.4435 9 19.1297 9 18.75Z" />
                    </svg>
                    <span class="btn-label">导入文件</span>
                </button>
                <button class="toolbar-btn" id="clearBtn" title="清空内容">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M12 1.75a3.25 3.25 0 0 1 3.245 3.066L15.25 5h5.25a.75.75 0 0 1 .102 1.493L20.5 6.5h-.796l-1.28 13.02a2.75 2.75 0 0 1-2.561 2.474l-.176.006H8.313a2.75 2.75 0 0 1-2.714-2.307l-.023-.174L4.295 6.5H3.5a.75.75 0 0 1-.743-.648L2.75 5.75a.75.75 0 0 1 .648-.743L3.5 5h5.25A3.25 3.25 0 0 1 12 1.75Zm6.197 4.75H5.802l1.267 12.872a1.25 1.25 0 0 0 1.117 1.122l.127.006h7.374c.6 0 1.109-.425 1.225-1.002l.02-.126L18.196 6.5ZM13.75 9.25a.75.75 0 0 1 .743.648L14.5 10v7a.75.75 0 0 1-1.493.102L13 17v-7a.75.75 0 0 1 .75-.75Zm-3.5 0a.75.75 0 0 1 .743.648L11 10v7a.75.75 0 0 1-1.493.102L9.5 17v-7a.75.75 0 0 1 .75-.75Zm1.75-6a1.75 1.75 0 0 0-1.744 1.606L10.25 5h3.5A1.75 1.75 0 0 0 12 3.25Z" />
                    </svg>
                    <span class="btn-label">清空内容</span>
                </button>
                <button class="toolbar-btn" id="historyBtn" title="历史记录">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M12 3a9 9 0 1 1-8.963 8.182.75.75 0 1 1 1.494.135 7.46 7.46 0 0 0 2.166 5.986A7.46 7.46 0 0 0 12 19.5 7.5 7.5 0 1 0 5.997 7.502h2.756a.75.75 0 0 1 .102 1.493l-.102.007H4.25a.75.75 0 0 1-.743-.648L3.5 8.252v-4.5a.75.75 0 0 1 1.493-.102L5 3.752l-.001 2.591A8.986 8.986 0 0 1 12 3Zm-.75 4a.75.75 0 0 1 .743.648L12 7.75V12h2.25a.75.75 0 0 1 .102 1.493l-.102.007h-3a.75.75 0 0 1-.743-.648l-.007-.102v-5a.75.75 0 0 1 .75-.75Z" />
                    </svg>
                    <span class="btn-label">历史记录</span>
                </button>
            </div>
            <div class="history-section">
                <div class="history-header"
                    style="display: flex; justify-content: space-between; align-items: center; padding-right: 8px; margin-bottom: 12px;">
                    <div class="history-title" style="margin-bottom: 0; display: flex; align-items: center; gap: 6px;">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" style="opacity: 0.8;">
                            <path
                                d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z" />
                        </svg>
                        <span>历史记录</span>
                    </div>
                    <button class="clear-history-btn" id="clearHistoryBtn" title="清空历史">
                        <svg viewBox="0 0 24 24" width="16" height="16">
                            <path fill="currentColor"
                                d="M16 9v10H8V9h8m-1.5-6h-5l-1 1H5v2h14V4h-3.5l-1-1zM18 7H6v12c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7z" />
                        </svg>
                    </button>
                </div>
                <div class="history-list" id="historyList">
                    <!-- 历史记录项将在这里动态生成 -->
                </div>

            </div>
        </div>
        <div class="main-layout" id="mainLayout">
            <!-- 左侧面板 -->
            <div class="left-panel" id="leftPanel">
                <div class="left-content">
                    <div class="squeeze-mask" id="leftMask"></div>
                    <div class="drag-overlay" id="dragOverlay">拖入图片以添加</div>

                    <!-- Batch Toolbar (Top Left) -->
                    <div class="batch-toolbar" id="batchToolbar">
                        <button class="batch-tool-btn" id="batchAddBtn" title="新建检测项">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z" />
                            </svg>
                        </button>
                        <button class="batch-tool-btn" id="batchFileBtn" title="文件">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z" />
                            </svg>
                        </button>
                        <button class="batch-tool-btn" id="batchClearBtn" title="清空列表">
                            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                            </svg>
                        </button>
                    </div>

                    <!-- Batch List Container -->
                    <div class="batch-list-container" id="batchListContainer">
                        <!-- Items will be injected here -->
                    </div>

                    <!-- 编辑选项 -->
                    <div class="edit-options" id="editOptions">
                        <button class="edit-btn" id="editCutBtn" title="剪切" disabled>
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M12.14 9.341v.002L7.37 2.328a.75.75 0 1 0-1.24.844l5.13 7.545-2.395 3.743a4 4 0 1 0 1.178.943l2.135-3.337 2.065 3.036a4 4 0 1 0 1.261-.813l-2.447-3.597.002-.002-.918-1.348Zm-7.64 8.66a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Zm10 0a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Z" />
                                <path d="m13.938 9.316 3.943-6.162a.75.75 0 1 0-1.263-.808L13.02 7.968l.918 1.348Z" />
                            </svg>
                        </button>
                        <button class="edit-btn" id="editOptionsPasteBtn" title="粘贴">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M12.753 2c1.158 0 2.111.875 2.234 2h1.763a2.25 2.25 0 0 1 2.245 2.096L19 6.25a.75.75 0 0 1-.647.742L18.249 7a.75.75 0 0 1-.742-.647L17.5 6.25a.75.75 0 0 0-.648-.743L16.75 5.5h-2.132a2.244 2.244 0 0 1-1.865.993H9.247c-.777 0-1.461-.393-1.865-.992L5.25 5.5a.75.75 0 0 0-.743.648L4.5 6.25v13.505c0 .38.282.693.648.743l.102.007h3a.75.75 0 0 1 .743.647l.007.102a.75.75 0 0 1-.75.75h-3a2.25 2.25 0 0 1-2.245-2.095L3 19.755V6.25a2.25 2.25 0 0 1 2.096-2.245L5.25 4h1.763a2.247 2.247 0 0 1 2.234-2h3.506Zm5.997 6a2.25 2.25 0 0 1 2.245 2.096l.005.154v9.5a2.25 2.25 0 0 1-2.096 2.245L18.75 22h-6.5a2.25 2.25 0 0 1-2.245-2.096L10 19.75v-9.5a2.25 2.25 0 0 1 2.096-2.245L12.25 8h6.5Zm0 1.5h-6.5a.75.75 0 0 0-.743.648l-.007.102v9.5c0 .38.282.694.648.743l.102.007h6.5a.75.75 0 0 0 .743-.648l.007-.102v-9.5a.75.75 0 0 0-.648-.743L18.75 9.5Zm-5.997-6H9.247a.747.747 0 0 0 0 1.493h3.506a.747.747 0 1 0 0-1.493Z" />
                            </svg>
                        </button>
                        <button class="edit-btn" id="editUndoBtn" title="撤销" disabled>
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M4.75 2a.75.75 0 0 1 .743.648l.007.102v5.69l4.574-4.56a6.41 6.41 0 0 1 8.879-.179l.186.18a6.41 6.41 0 0 1 0 9.063l-8.846 8.84a.75.75 0 0 1-1.06-1.062l8.845-8.838a4.91 4.91 0 0 0-6.766-7.112l-.178.17L6.562 9.5h5.688a.75.75 0 0 1 .743.648l.007.102a.75.75 0 0 1-.648.743L12.25 11h-7.5a.75.75 0 0 1-.743-.648L4 10.25v-7.5A.75.75 0 0 1 4.75 2Z" />
                            </svg>
                        </button>
                        <button class="edit-btn" id="editRedoBtn" title="重做" disabled>
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M19.25 2a.75.75 0 0 0-.743.648l-.007.102v5.69l-4.574-4.56a6.41 6.41 0 0 0-8.878-.179l-.186.18a6.41 6.41 0 0 0 0 9.063l8.845 8.84a.75.75 0 0 0 1.06-1.062l-8.845-8.838a4.91 4.91 0 0 1 6.766-7.112l.178.17L17.438 9.5H11.75a.75.75 0 0 0-.743.648L11 10.25c0 .38.282.694.648.743l.102.007h7.5a.75.75 0 0 0 .743-.648L20 10.25v-7.5a.75.75 0 0 0-.75-.75Z" />
                            </svg>
                        </button>
                        <div class="toolbar-separator"></div>
                        <button class="edit-btn" id="editFormatPainterBtn" title="清除格式">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M2.212 13.82c.146.12.33.18.55.18.36 0 .609-.188.744-.563l1.074-2.92h4.831l1.083 2.92c.135.375.384.563.745.563.22 0 .4-.06.541-.18a.587.587 0 0 0 .22-.465c0-.108-.031-.244-.093-.407L7.973 2.702c-.18-.468-.5-.702-.956-.702-.485 0-.818.237-.998.71L2.093 12.948c-.062.163-.093.299-.093.407 0 .185.07.34.212.465ZM8.98 9.27H5.02L6.975 3.9h.05L8.98 9.269ZM13 13.105l1.748-1.748c-.23-.482-.344-1.056-.344-1.722 0-.93.227-1.682.681-2.256.46-.578 1.05-.868 1.769-.868.746 0 1.336.281 1.769.844.356.463.566 1.061.629 1.793.424.14.823.378 1.161.715l.286.286a7.47 7.47 0 0 0 .017-.514c0-1.32-.327-2.377-.982-3.173-.654-.795-1.514-1.192-2.58-1.192a3.13 3.13 0 0 0-1.598.414c-.47.275-.841.657-1.112 1.144h-.032V2.755a.752.752 0 0 0-.203-.544.653.653 0 0 0-.503-.211.68.68 0 0 0-.511.21.77.77 0 0 0-.195.545v10.35Zm3.982 8.395h3.02a.75.75 0 1 1 0 1.5H14.5l.002-.007a1.94 1.94 0 0 1-1.208-.563l-2.724-2.724a1.95 1.95 0 0 1 .002-2.76l6.374-6.374a1.95 1.95 0 0 1 2.759-.001l2.724 2.723a1.95 1.95 0 0 1-.002 2.76L16.981 21.5Zm1.026-9.867L13.85 15.79l3.36 3.36 4.157-4.157a.45.45 0 0 0 .001-.638l-2.724-2.724a.45.45 0 0 0-.637.002ZM12.79 16.85l-1.157 1.157a.45.45 0 0 0-.001.637l2.724 2.724a.45.45 0 0 0 .637-.002l1.157-1.157-3.36-3.36Z" />
                            </svg>
                        </button>
                        <div class="edit-btn-group" id="editFormatGroup">
                            <button class="edit-btn" id="editFormatBtn" title="文本格式">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                    <path
                                        d="M12 20.5a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Zm5 0a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Zm5 0a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Zm-6.893-2.47-1.232-3.005H5.75L3.9 19.6c-.133.333-.358.5-.675.5-.233 0-.408-.058-.525-.175a.733.733 0 0 1-.2-.475v-.075c0-.1.008-.175.025-.225L9.125 3c.133-.333.383-.5.75-.5a.63.63 0 0 1 .425.15c.133.083.233.2.3.35l6.315 15.439a2.488 2.488 0 0 0-1.808-.408ZM9.775 5l-3.45 8.55h6.95L9.775 5Z" />
                                </svg>
                            </button>
                            <div class="dropdown-menu format-menu" id="formatDropdown">
                                <div class="dropdown-item-row" style="padding: 4px 6px;">
                                    <div class="zoom-controls"
                                        style="display: flex; gap: 6px; width: 100%; background: transparent; padding: 0;">
                                        <div class="dropdown-item" id="editFontDec" title="减小字号"
                                            style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                                <path
                                                    d="M0.99 19h2.42l1.27-3.58h5.65L11.59 19h2.42L8.75 5h-2.5L0.99 19zM7.5 7.62L9.38 13.5h-3.76L7.5 7.62zM19 13h-8v-2h8v2z" />
                                            </svg>
                                        </div>
                                        <div class="dropdown-item" id="editFontInc" title="增大字号"
                                            style="flex: 1; display: flex; align-items: center; justify-content: center;">
                                            <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                                <path
                                                    d="M0.99 19h2.42l1.27-3.58h5.65L11.59 19h2.42L8.75 5h-2.5L0.99 19zM7.5 7.62L9.38 13.5h-3.76L7.5 7.62zM19 13h-3v3h-2v-3h-3v-2h3V8h2v3h3v2z" />
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                                <div class="dropdown-item" data-command="bold" title="加粗">
                                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                        <path
                                            d="M6.935 4.44A1.5 1.5 0 0 1 7.996 4h4.383C15.017 4 17 6.182 17 8.625a4.63 4.63 0 0 1-.865 2.682c1.077.827 1.866 2.12 1.866 3.813C18 18.232 15.3 20 13.12 20H8a1.5 1.5 0 0 1-1.5-1.5l-.004-13c0-.397.158-.779.44-1.06ZM9.5 10.25h2.88c.903 0 1.62-.76 1.62-1.625S13.281 7 12.38 7H9.498l.002 3.25Zm0 3V17h3.62c.874 0 1.88-.754 1.88-1.88 0-1.13-.974-1.87-1.88-1.87H9.5Z" />
                                    </svg>
                                    <span>加粗</span>
                                </div>
                                <div class="dropdown-item" data-command="italic" title="斜体">
                                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                        <path
                                            d="M9.75 4h8.504a.75.75 0 0 1 .102 1.493l-.102.006h-3.197L10.037 18.5h4.213a.75.75 0 0 1 .742.648l.007.102a.75.75 0 0 1-.648.743L14.25 20h-9.5a.747.747 0 0 1-.746-.75c0-.38.28-.694.645-.743l.101-.007h3.685l.021-.065L13.45 5.499h-3.7a.75.75 0 0 1-.742-.648L9 4.75a.75.75 0 0 1 .648-.743L9.751 4h8.503-8.503Z" />
                                    </svg>
                                    <span>斜体</span>
                                </div>
                                <div class="dropdown-item" data-command="underline" title="下划线">
                                    <svg width="22" height="22" viewBox="0 0 24 24" fill="currentColor">
                                        <path
                                            d="M6.75 19h10.5a.75.75 0 0 1 .102 1.493l-.102.007H6.75a.75.75 0 0 1-.102-1.493L6.75 19h10.5-10.5Zm10.5-15a.75.75 0 0 1 .743.648L18 4.75v6c0 4.394-2.063 6.75-6.003 6.75-3.855 0-5.91-2.255-5.994-6.466L6 10.75v-6a.75.75 0 0 1 1.493-.102l.007.102v6C7.496 14.358 8.933 16 11.997 16c2.985 0 4.428-1.56 4.5-4.976l.003-.274v-6a.75.75 0 0 1 .75-.75Z" />
                                    </svg>
                                    <span>下划线</span>
                                </div>
                            </div>
                        </div>
                        <div class="edit-btn-group" id="editHeadingGroup">
                            <button class="edit-btn" id="editHeadingBtn" title="段落格式">
                                <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                    <path
                                        d="M3.78 3.22a.75.75 0 0 0-1.06 1.06l1.47 1.47-1.47 1.47a.75.75 0 0 0 1.06 1.06l2-2a.75.75 0 0 0 0-1.06l-2-2ZM9.75 5a.75.75 0 0 0 0 1.5h11.5a.75.75 0 0 0 0-1.5H9.75ZM2.75 18a.75.75 0 0 0 0 1.5h18.5a.75.75 0 0 0 0-1.5H2.75ZM2 12.25a.75.75 0 0 1 .75-.75h18.5a.75.75 0 0 1 0 1.5H2.75a.75.75 0 0 1-.75-.75Z" />
                                </svg>
                            </button>
                            <div class="dropdown-menu" id="headingDropdown">
                                <div class="dropdown-item heading-item" data-cmd="formatBlock" data-val="H1">
                                    <span class="heading-icon" style="font-weight: 800; font-size: 16px;">H1</span>
                                    <span>标题 1</span>
                                </div>
                                <div class="dropdown-item heading-item" data-cmd="formatBlock" data-val="H2">
                                    <span class="heading-icon" style="font-weight: 700; font-size: 15px;">H2</span>
                                    <span>标题 2</span>
                                </div>
                                <div class="dropdown-item heading-item" data-cmd="formatBlock" data-val="H3">
                                    <span class="heading-icon" style="font-weight: 600; font-size: 14px;">H3</span>
                                    <span>标题 3</span>
                                </div>
                                <div class="dropdown-item heading-item" data-cmd="formatBlock" data-val="P">
                                    <span class="heading-icon" style="font-size: 14px;">¶</span>
                                    <span>正文</span>
                                </div>
                            </div>
                        </div>
                        <div class="toolbar-separator"></div>
                        <button class="edit-btn" data-command="justifyLeft" title="左对齐">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z" />
                            </svg>
                        </button>
                        <button class="edit-btn" data-command="justifyCenter" title="居中">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z" />
                            </svg>
                        </button>
                        <button class="edit-btn" data-command="justifyRight" title="右对齐">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z" />
                            </svg>
                        </button>
                        <div class="toolbar-separator"></div>
                        <button class="edit-btn" id="editAddImageBtn" title="添加图片">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M17.75 3A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75V6.25A3.25 3.25 0 0 1 6.25 3h11.5Zm.58 16.401-5.805-5.686a.75.75 0 0 0-.966-.071l-.084.07-5.807 5.687c.182.064.378.099.582.099h11.5c.203 0 .399-.035.58-.099l-5.805-5.686L18.33 19.4ZM17.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v11.5c0 .208.036.408.103.594l5.823-5.701a2.25 2.25 0 0 1 3.02-.116l.128.116 5.822 5.702c.067-.186.104-.386.104-.595V6.25a1.75 1.75 0 0 0-1.75-1.75Zm-2.498 2a2.252 2.252 0 1 1 0 4.504 2.252 2.252 0 0 1 0-4.504Zm0 1.5a.752.752 0 1 0 0 1.504.752.752 0 0 0 0-1.504Z" />
                            </svg>
                        </button>
                        <div class="toolbar-separator"></div>
                        <button class="edit-btn close-edit-btn" id="closeEditBtn" title="完成编辑">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
                            </svg>
                        </button>
                    </div>

                    <div class="context-menu" id="editContextMenu">
                        <div class="context-menu-item" id="ctxSearch">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3.441 9.955a4.926 4.926 0 0 0 6.233 7.571l4.256 4.257a.773.773 0 0 0 1.169-1.007l-.075-.087-4.218-4.218a4.927 4.927 0 0 0-7.365-6.516Zm8.585-7.957c-4.756 0-8.736 3.319-9.751 7.767a5.912 5.912 0 0 1 2.235-1.74A8.525 8.525 0 0 1 8.906 4.09l-.107.174c-.538.893-.971 2.011-1.275 3.28.499.05.99.164 1.465.34.632-2.628 1.823-4.385 3.037-4.385l.115.005c1.266.116 2.488 2.118 3.056 4.996h-4.998a5.955 5.955 0 0 1 1.55 1.499l3.674.001a18.974 18.974 0 0 1-.136 5h-2.645a5.895 5.895 0 0 1-.299.842l-.129.272-.122.229.158.157h2.715c-.203.749-.451 1.418-.732 1.985l1.105 1.107c.492-.858.892-1.908 1.18-3.09l2.722-.002a8.537 8.537 0 0 1-3.734 3.26l.225.223.125.14c.22.296.344.625.378.953A10.002 10.002 0 0 0 22.027 12c0-5.524-4.478-10.002-10.001-10.002Zm-2.712 9.05a3.38 3.38 0 1 1-4.78 4.78 3.38 3.38 0 0 1 4.78-4.78ZM16.932 10l3.358-.001.008.03c.15.633.23 1.292.23 1.97a8.48 8.48 0 0 1-.545 3l-3.174.002c.143-.95.218-1.958.218-3.001 0-.684-.032-1.353-.095-2Zm-1.787-5.911.023.008A8.53 8.53 0 0 1 19.776 8.5h-3.049c-.313-1.753-.86-3.278-1.582-4.41Z" />
                            </svg>
                            <span>搜索</span>
                            <span class="shortcut-hint" id="ctxSearchText"></span>
                        </div>
                        <div class="context-menu-item" id="ctxGoTo">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z" />
                            </svg>
                            <span>转到</span>
                            <span class="shortcut-hint" id="ctxGoToUrl"></span>
                        </div>
                        <div class="context-menu-separator" id="ctxSearchSep"></div>
                        <div class="context-menu-item" id="ctxCut">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M12.14 9.341v.002L7.37 2.328a.75.75 0 1 0-1.24.844l5.13 7.545-2.395 3.743a4 4 0 1 0 1.178.943l2.135-3.337 2.065 3.036a4 4 0 1 0 1.261-.813l-2.447-3.597.002-.002-.918-1.348Zm-7.64 8.66a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Zm10 0a2.5 2.5 0 1 1 5 0 2.5 2.5 0 0 1-5 0Z" />
                                <path d="m13.938 9.316 3.943-6.162a.75.75 0 1 0-1.263-.808L13.02 7.968l.918 1.348Z" />
                            </svg>
                            <span>剪切</span>
                            <span class="shortcut-hint">Ctrl+X</span>
                        </div>
                        <div class="context-menu-item" id="ctxCopy">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
                            </svg>
                            <span>复制</span>
                            <span class="shortcut-hint">Ctrl+C</span>
                        </div>
                        <div class="context-menu-item" id="ctxPaste">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M13.75 2a2.25 2.25 0 0 1 2.245 2.096L16 4.25c0-.085-.005-.168-.014-.25h1.764A2.25 2.25 0 0 1 20 6.25v13.5A2.25 2.25 0 0 1 17.75 22H6.25A2.25 2.25 0 0 1 4 19.75V6.25A2.25 2.25 0 0 1 6.25 4h1.764c-.007.058-.01.117-.013.176L8 4.25A2.25 2.25 0 0 1 10.25 2h3.5Zm0 4.5h-3.5a2.248 2.248 0 0 1-1.892-1.033l.021.033H6.25a.75.75 0 0 0-.75.75v13.5c0 .414.336.75.75.75h11.5a.75.75 0 0 0 .75-.75V6.25a.75.75 0 0 0-.75-.75h-2.129l.021-.033A2.248 2.248 0 0 1 13.75 6.5Zm0-3h-3.5a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5Z" />
                            </svg>
                            <span>粘贴</span>
                            <span class="shortcut-hint">Ctrl+V</span>
                        </div>
                        <div class="context-menu-item" id="ctxPastePlain">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M13.75 2a2.25 2.25 0 0 1 2.236 2h1.764A2.25 2.25 0 0 1 20 6.25v8.272l-1.5-3.328V6.25a.75.75 0 0 0-.75-.75h-2.129c-.404.603-1.091 1-1.871 1h-3.5c-.78 0-1.467-.397-1.871-1H6.25a.75.75 0 0 0-.75.75v13.5c0 .414.336.75.75.75h5.05l-.173.385c-.164.366-.17.764-.046 1.115H6.25A2.25 2.25 0 0 1 4 19.75V6.25A2.25 2.25 0 0 1 6.25 4h1.764a2.25 2.25 0 0 1 2.236-2h3.5Zm2.245 2.096L16 4.25c0-.052-.002-.103-.005-.154ZM13.75 3.5h-3.5a.75.75 0 0 0 0 1.5h3.5a.75.75 0 0 0 0-1.5Z" />
                                <path
                                    d="M17.448 11.294a.5.5 0 0 0-.912 0l-2.693 5.991a.52.52 0 0 0-.01.02l-1.793 3.99a.5.5 0 1 0 .912.41L14.617 18h4.756l1.67 3.706a.5.5 0 0 0 .912-.412l-1.799-3.99a.52.52 0 0 0-.009-.02l-2.7-5.99ZM18.923 17h-3.856l1.926-4.282L18.923 17Z" />
                            </svg>
                            <span>仅粘贴文本</span>
                            <span class="shortcut-hint">Ctrl+Shift+V</span>
                        </div>
                        <div class="context-menu-item" id="ctxDelete">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                            </svg>
                            <span>删除</span>
                            <span class="shortcut-hint">Del</span>
                        </div>
                        <div class="context-menu-item" id="ctxSaveAs">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M19 12v7H5v-7H3v7c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zm-6 .67l2.59-2.58L17 11.5l-5 5-5-5 1.41-1.41L11 12.67V3h2v9.67z" />
                            </svg>
                            <span>另存为</span>
                        </div>
                        <div class="context-menu-separator ctx-format-group"></div>
                        <div class="context-menu-item ctx-format-group">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M5 17v2h14v-2H5zm4.5-4.2h5l.9 2.2h2.1L12.75 4h-1.5L6.5 15h2.1l.9-2.2zM12 5.98L13.87 11h-3.74L12 5.98z" />
                            </svg>
                            <span>文本格式</span>

                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6" />
                            </svg>
                            <div class="context-submenu">
                                <div class="context-menu-item" data-cmd="bold">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                        <path
                                            d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z" />
                                    </svg>
                                    <span>加粗</span>
                                    <span class="shortcut-hint">Ctrl+B</span>
                                </div>
                                <div class="context-menu-item" data-cmd="italic">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                        <path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z" />
                                    </svg>
                                    <span>斜体</span>
                                    <span class="shortcut-hint">Ctrl+I</span>
                                </div>
                                <div class="context-menu-item" data-cmd="underline">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                        <path
                                            d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z" />
                                    </svg>
                                    <span>下划线</span>
                                    <span class="shortcut-hint">Ctrl+U</span>
                                </div>
                                <div class="context-menu-item" data-cmd="removeFormat">
                                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                        <path
                                            d="M2.212 13.82c.146.12.33.18.55.18.36 0 .609-.188.744-.563l1.074-2.92h4.831l1.083 2.92c.135.375.384.563.745.563.22 0 .4-.06.541-.18a.587.587 0 0 0 .22-.465c0-.108-.031-.244-.093-.407L7.973 2.702c-.18-.468-.5-.702-.956-.702-.485 0-.818.237-.998.71L2.093 12.948c-.062.163-.093.299-.093.407 0 .185.07.34.212.465ZM8.98 9.27H5.02L6.975 3.9h.05L8.98 9.269ZM13 13.105l1.748-1.748c-.23-.482-.344-1.056-.344-1.722 0-.93.227-1.682.681-2.256.46-.578 1.05-.868 1.769-.868.746 0 1.336.281 1.769.844.356.463.566 1.061.629 1.793.424.14.823.378 1.161.715l.286.286a7.47 7.47 0 0 0 .017-.514c0-1.32-.327-2.377-.982-3.173-.654-.795-1.514-1.192-2.58-1.192a3.13 3.13 0 0 0-1.598.414c-.47.275-.841.657-1.112 1.144h-.032V2.755a.752.752 0 0 0-.203-.544.653.653 0 0 0-.503-.211.68.68 0 0 0-.511.21.77.77 0 0 0-.195.545v10.35Zm3.982 8.395h3.02a.75.75 0 1 1 0 1.5H14.5l.002-.007a1.94 1.94 0 0 1-1.208-.563l-2.724-2.724a1.95 1.95 0 0 1 .002-2.76l6.374-6.374a1.95 1.95 0 0 1 2.759-.001l2.724 2.723a1.95 1.95 0 0 1-.002 2.76L16.981 21.5Zm1.026-9.867L13.85 15.79l3.36 3.36 4.157-4.157a.45.45 0 0 0 .001-.638l-2.724-2.724a.45.45 0 0 0-.637.002ZM12.79 16.85l-1.157 1.157a.45.45 0 0 0-.001.637l2.724 2.724a.45.45 0 0 0 .637-.002l1.157-1.157-3.36-3.36Z" />
                                    </svg>
                                    <span>清除格式</span>
                                </div>
                            </div>
                        </div>
                        <div class="context-menu-item ctx-format-group">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M4 19h6v-2H4v2zM20 5H4v2h16V5zm-3 6H4v2h13.25c1.1 0 2 .9 2 2s-.9 2-2 2H15v-2l-3 3 3 3v-2h2c2.21 0 4-1.79 4-4s-1.79-4-4-4z" />
                            </svg>
                            <span>段落级别</span>

                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                <polyline points="9 18 15 12 9 6" />
                            </svg>
                            <div class="context-submenu">
                                <div class="context-menu-item" data-cmd="formatBlock" data-val="H1">
                                    <span style="font-weight: 800; font-size: 16px;">H1</span>
                                    <span>标题 1</span>
                                </div>
                                <div class="context-menu-item" data-cmd="formatBlock" data-val="H2">
                                    <span style="font-weight: 700; font-size: 15px;">H2</span>
                                    <span>标题 2</span>
                                </div>
                                <div class="context-menu-item" data-cmd="formatBlock" data-val="H3">
                                    <span style="font-weight: 600; font-size: 14px;">H3</span>
                                    <span>标题 3</span>
                                </div>
                                <div class="context-menu-item" data-cmd="formatBlock" data-val="P">
                                    <span style="font-size: 14px;">¶</span>
                                    <span>正文</span>
                                </div>
                            </div>
                        </div>
                        <div class="context-menu-separator ctx-format-group"></div>
                        <div class="context-menu-item" id="ctxSelectAll">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z" />
                            </svg>
                            <span>全选</span>
                            <span class="shortcut-hint">Ctrl+A</span>
                        </div>
                        <div class="context-menu-item" id="ctxAddImage">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M17.75 3A3.25 3.25 0 0 1 21 6.25v11.5A3.25 3.25 0 0 1 17.75 21H6.25A3.25 3.25 0 0 1 3 17.75V6.25A3.25 3.25 0 0 1 6.25 3h11.5Zm.58 16.401-5.805-5.686a.75.75 0 0 0-.966-.071l-.084.07-5.807 5.687c.182.064.378.099.582.099h11.5c.203 0 .399-.035.58-.099l-5.805-5.686L18.33 19.4ZM17.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v11.5c0 .208.036.408.103.594l5.823-5.701a2.25 2.25 0 0 1 3.02-.116l.128.116 5.822 5.702c.067-.186.104-.386.104-.595V6.25a1.75 1.75 0 0 0-1.75-1.75Zm-2.498 2a2.252 2.252 0 1 1 0 4.504 2.252 2.252 0 0 1 0-4.504Zm0 1.5a.752.752 0 1 0 0 1.504.752.752 0 0 0 0-1.504Z" />
                            </svg>
                            <span>添加图片</span>
                        </div>
                    </div>

                    <div class="context-menu" id="batchContextMenu">
                        <div class="context-menu-item" id="ctxBatchEdit">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z" />
                            </svg>
                            <span>编辑内容</span>
                        </div>
                        <div class="context-menu-item" id="ctxBatchView">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" />
                            </svg>
                            <span>查看结果</span>
                        </div>
                        <div class="context-menu-separator"></div>
                        <div class="context-menu-item" id="ctxBatchDelete">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                                <path
                                    d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
                            </svg>
                            <span>删除</span>
                        </div>
                    </div>

                    <!-- 内容区域 -->
                    <div class="content-area">
                        <!-- 文本容器（视觉矩形框） -->
                        <div class="text-container">
                            <!-- 文本输入 -->
                            <div contenteditable="true" class="text-input" id="textInput" placeholder="请输入要检测的新闻内容...">
                            </div>
                        </div>
                        <!-- 图片预览 -->
                        <div class="image-preview-container" id="imagePreview"></div>

                        <!-- 状态栏 -->
                        <div class="editor-status-bar">
                            <span id="wordCount">0 字</span>
                            <span class="status-separator">|</span>
                            <span id="imageCount">0 图片</span>
                        </div>
                    </div>

                    <!-- 底部操作区 -->
                    <div class="bottom-area">
                        <!-- 检测按钮 -->
                        <button class="detect-btn" id="detectBtn">开始检测</button>
                    </div>
                </div>
            </div>

            <!-- 分隔线 -->
            <div class="resizer" id="resizer"></div>

            <!-- 右侧面板 -->
            <div class="right-panel" id="rightPanel">
                <div class="squeeze-mask" id="rightMask"></div>
                <button class="exit-detection-btn" id="exitDetectionBtn" title="退出">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
                        <path
                            d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
                    </svg>
                </button>
                <div class="result-content">

                    <!-- 初始状态 -->
                    <div class="initial-state" id="initialState">
                        <div class="initial-icon">
                            <!-- 彩色放大镜SVG -->
                            <!-- 在线彩色放大镜图标，线性风格，主色蓝辅色黄 -->
                            <svg width="64" height="64" viewBox="0 0 64 64" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <circle cx="28" cy="28" r="16" stroke="#2196f3" stroke-width="1.5" fill="#e3f6fd" />
                                <circle cx="28" cy="28" r="8" stroke="#2196f3" stroke-width="1.5" fill="#fff" />
                                <circle cx="28" cy="28" r="3" fill="#4fc3f7" />
                                <rect x="38" y="38" width="12" height="5" rx="2.5" transform="rotate(45 38 38)"
                                    fill="#fffde7" stroke="#ffc107" stroke-width="1.5" />
                                <line x1="36" y1="36" x2="48" y2="48" stroke="#2196f3" stroke-width="1.5"
                                    stroke-linecap="round" />
                            </svg>
                        </div>
                        <div class="initial-title">准备就绪</div>
                        <div class="initial-description">
                            在左侧输入新闻内容或上传相关图片，点击"开始检测"按钮即可进行假新闻分析。
                            系统将综合评估内容的真实性，为您提供详细的检测报告。
                        </div>
                    </div>

                    <!-- 检测结果 -->
                    <div class="result-item" id="resultItem">
                        <div class="result-header-container"
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 class="result-title" style="margin-bottom: 0;">检测结果</h2>
                            <div class="toolbar-btn more-menu" id="exportBtn" title="导出结果" tabindex="0" style="position: relative;">
                                <svg xmlns="http://www.w3.org/2000/svg" height="20" viewBox="0 -960 960 960" width="20"
                                    fill="currentColor">
                                    <path
                                        d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z" />
                                </svg>
                                <div class="dropdown-menu" id="exportDropdown">
                                    <div class="dropdown-item" data-format="html">
                                        <div class="dropdown-item-icon">
                                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                                <polyline points="14 2 14 8 20 8"></polyline>
                                                <path d="m10 13-2 2 2 2"></path>
                                                <path d="m14 17 2-2-2-2"></path>
                                            </svg>
                                        </div>
                                        <span>导出为 HTML</span>
                                    </div>
                                    <div class="dropdown-item" data-format="pdf">
                                        <div class="dropdown-item-icon">
                                            <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                                <polyline points="14 2 14 8 20 8"></polyline>
                                                <path d="M9 15h6"></path>
                                                <path d="M9 11h6"></path>
                                                <path d="M9 19h6"></path>
                                            </svg>
                                        </div>
                                        <span>导出为 PDF</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="result-score">
                            <div class="score-circle-container" id="scoreCircleContainer">
                                <svg class="score-svg" viewBox="0 0 100 100">
                                    <circle class="score-bg" cx="50" cy="50" r="45"></circle>
                                    <circle class="score-progress" id="scoreProgress" cx="50" cy="50" r="45"></circle>
                                </svg>
                                <div class="score-text" id="scoreText">0%</div>
                            </div>
                            <div class="score-details">
                                <div class="score-label">真实性评分</div>
                                <div class="score-value" id="scoreValue">0%</div>
                                <div class="score-description" id="scoreDescription">等待检测...</div>
                            </div>
                        </div>

                        <div class="result-analysis">
                            <div class="analysis-title">详细分析</div>
                            <div class="analysis-item">
                                <div class="analysis-icon positive">✓</div>
                                <div class="analysis-text">内容来源可靠，引用了权威媒体的数据</div>
                            </div>
                            <div class="analysis-item">
                                <div class="analysis-icon positive">✓</div>
                                <div class="analysis-text">语言表达客观，无明显情绪化倾向</div>
                            </div>
                            <div class="analysis-item">
                                <div class="analysis-icon neutral">!</div>
                                <div class="analysis-text">部分信息需要进一步核实</div>
                            </div>
                            <div class="analysis-item">
                                <div class="analysis-icon positive">✓</div>
                                <div class="analysis-text">图片内容与文字描述相符</div>
                            </div>
                        </div>

                        <!-- 解析内容 -->
                        <div class="parsed-content" id="parsedContent" style="display: none;">
                            <h3 class="parsed-title" id="parsedTitle"></h3>
                            <div class="parsed-images-container" id="parsedImages"></div>
                            <div class="parsed-text" id="parsedText"></div>
                        </div>
                    </div>

                    <!-- 加载状态 -->
                    <div class="loading-state" id="loadingState">
                        <div class="loading-spinner-large"></div>
                        <div class="loading-text" id="loadingText">正在解析网页内容...</div>
                        <div class="progress-container">
                            <div class="progress-bar" id="progressBar"></div>
                        </div>
                        <button class="cancel-extract-btn" id="cancelExtractBtn" style="display: none;"></button>
                    </div>

                    <!-- 错误状态 -->
                    <div class="error-state" id="errorState">
                        <div class="error-icon">⚠️</div>
                        <div class="error-message">解析失败</div>
                        <div class="error-detail" id="errorDetail">无法获取网页内容，请检查链接是否有效</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu for Result (Moved to body level) -->
    <div class="context-menu" id="resultContextMenu">
        <div class="context-menu-item" id="ctxResultSearch">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
            </svg>
            <span>搜索</span>
            <span class="shortcut-hint" id="ctxResultSearchText"></span>
        </div>
        <div class="context-menu-item" id="ctxResultGoTo">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z" />
            </svg>
            <span>转到</span>
            <span class="shortcut-hint" id="ctxResultGoToUrl"></span>
        </div>
        <div class="context-menu-separator" id="ctxResultSearchSep"></div>
        <div class="context-menu-item" id="ctxResultCopy">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z" />
            </svg>
            <span>复制</span>
            <span class="shortcut-hint">Ctrl+C</span>
        </div>
        <div class="context-menu-item" id="ctxResultSelectAll">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z" />
            </svg>
            <span>全选</span>
            <span class="shortcut-hint">Ctrl+A</span>
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="ctxExportResult">
            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 -960 960 960" width="24" fill="currentColor">
                <path d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z" />
            </svg>
            <span>导出检测结果</span>
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" style="margin-left: auto;">
                <path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z" />
            </svg>
            <div class="context-submenu">
                <div class="context-menu-item" data-format="html">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <path d="m10 13-2 2 2 2"></path>
                        <path d="m14 17 2-2-2-2"></path>
                    </svg>
                    <span>导出为 HTML</span>
                </div>
                <div class="context-menu-item" data-format="pdf">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <path d="M9 15h6"></path>
                        <path d="M9 11h6"></path>
                        <path d="M9 19h6"></path>
                    </svg>
                    <span>导出为 PDF</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Context Menu for History -->
    <div class="context-menu" id="historyContextMenu">
        <div class="context-menu-item" id="ctxHistoryView">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path
                    d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z" />
            </svg>
            <span>查看</span>
        </div>
        <div class="context-menu-separator"></div>
        <div class="context-menu-item" id="ctxHistoryDelete">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                <path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z" />
            </svg>
            <span>删除</span>
        </div>
    </div>

    <!-- 图片预览模态框 -->
    <div class="image-modal" id="imageModal">
        <button class="modal-close" id="modalClose">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"
                stroke-linecap="round" stroke-linejoin="round">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
        </button>
        <img class="modal-image" id="modalImage" src="" alt="预览图片">
        <div id="modalReason" class="modal-reason"></div>
    </div>

    <!-- Search Results Components -->
    <div id="searchResultsBackdrop" class="search-overlay-backdrop"></div>
    <div id="searchResultsOverlay" class="search-results-overlay">
        <div class="search-results-header">
            <h3>搜索结果</h3>
            <button class="search-results-close" id="searchResultsClose">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            </button>
        </div>
        <div class="search-results-list" id="searchResultsList">
            <!-- Items injected here -->
        </div>
    </div>

    <!-- Toast 提示 -->
    <div class="toast" id="toast"></div>

    <!-- 自定义确认弹窗 -->
    <div class="custom-modal" id="customModal">
        <div class="custom-modal-content">
            <div class="custom-modal-title">清空内容</div>
            <div class="custom-modal-message">确定要清空页面吗？</div>
            <div class="custom-modal-actions">
                <button class="custom-modal-btn" id="modalConfirm">确定</button>
                <button class="custom-modal-btn" id="modalCancel">取消</button>
            </div>
        </div>
    </div>

    <script>
        // API Bridge for Web compatibility (Migration)
        window.api = {
            invoke: async (channel, ...args) => {
                try {
                    const response = await fetch('/api/invoke', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ channel, args })
                    });

                    if (response.status === 401) {
                        window.location.href = '/Login';
                        return;
                    }

                    const result = await response.json();
                    if (result.status !== 'fail') return result.data;
                    throw new Error(result.message || result.error || 'Server Error');
                } catch (error) {
                    console.error(`API Invoke Error (${channel}):`, error);
                    throw error;
                }
            },
            send: (channel, ...args) => {
                // For "send" calls, we can either use a generic endpoint or handle specific ones
                // Most original .send calls were for UI or log, so we log them
                console.log(`API Call(Send): ${channel}`, args);

                // If it's a cancel-extraction, we could potentially call an endpoint
                if (channel === 'cancel-extraction') {
                    fetch('/api/invoke', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ channel, args: [] })
                    }).catch(e => console.error('Cancel Extraction failed', e));
                }
            },
            on: (channel, callback) => {
                // Event proxy via window
                window.addEventListener(`api-${channel}`, (e) => callback(e, e.detail));
            }
        };

        // 下拉菜单逻辑 (通用处理)
        (function initDropdowns() {
            const dropdownConfigs = [
                { btnId: 'moreBtn', dropdownId: 'moreDropdown' },
                { btnId: 'userBtn', dropdownId: 'userDropdown' },
                { btnId: 'exportBtn', dropdownId: 'exportDropdown' }
            ];

            dropdownConfigs.forEach(cfg => {
                const btn = document.getElementById(cfg.btnId);
                const dropdown = document.getElementById(cfg.dropdownId);
                if (!btn || !dropdown) return;

                const toggle = (force) => {
                    const show = typeof force === 'boolean' ? force : !dropdown.classList.contains('show');
                    // Close others
                    if (show) {
                        document.querySelectorAll('.dropdown-menu.show').forEach(el => {
                            if (el !== dropdown) el.classList.remove('show');
                        });
                    }
                    dropdown.classList.toggle('show', show);
                };

                btn.addEventListener('click', e => { e.stopPropagation(); toggle(); });
                btn.addEventListener('keydown', e => {
                    if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }
                    else if (e.key === 'Escape') toggle(false);
                });
                dropdown.addEventListener('click', e => e.stopPropagation());

                document.addEventListener('pointerdown', e => {
                    if (!btn.contains(e.target)) toggle(false);
                });
            });

            // 暴露统一关闭方法
            window.__hideAllDropdowns = () => {
                document.querySelectorAll('.dropdown-menu.show').forEach(el => el.classList.remove('show'));
            };
            window.__hideMoreDropdown = window.__hideAllDropdowns; // 保持向后兼容
        })();

        // 获取用户信息
        (async function fetchUserInfo() {
            try {
                const res = await fetch('/auth/me');
                const data = await res.json();
                if (data.status !== 'fail') {
                    const user = data.user;
                    const display = document.getElementById('usernameDisplay');
                    if (display) display.textContent = user.username + (user.role === 'admin' ? ' (管理员)' : '');

                    // 管理员显示管理按钮
                    const adminBtn = document.getElementById('adminBtn');
                    if (adminBtn && user.role === 'admin') {
                        adminBtn.style.display = 'flex';
                    }

                    // 更新头像
                    const avatarImg = document.getElementById('topBarAvatar');
                    const userIcon = document.getElementById('topBarUserIcon');
                    if (avatarImg && userIcon) {
                        avatarImg.src = `/api/public/avatar/${user.id}`;
                        avatarImg.style.display = 'block';
                        avatarImg.onload = () => {
                            avatarImg.style.display = 'block';
                            userIcon.style.display = 'none';
                        };
                        avatarImg.onerror = () => {
                            avatarImg.style.display = 'none';
                            userIcon.style.display = 'block';
                        };
                    }
                }
            } catch (err) { console.error('Failed to fetch user info', err); }
        })();

        // 用户信息管理逻辑
        const changeAvatarBtn = document.getElementById('changeAvatarBtn');
        if (changeAvatarBtn) {
            changeAvatarBtn.addEventListener('click', async () => {
                const meRes = await fetch('/auth/me');
                const meData = await meRes.json();
                if (meData.status !== 'fail') {
                    window.userEditor.open({
                        userId: meData.user.id,
                        username: meData.user.username,
                        isAdminContext: false,
                        onSuccess: () => location.reload()
                    });
                }
            });
        }

        const adminBtn = document.getElementById('adminBtn');
        if (adminBtn) {
            adminBtn.addEventListener('click', () => {
                window.location.href = '/Admin';
            });
        }

        // 全屏显示功能
        const __fullScreenBtnEl = document.getElementById('fullScreenBtn');
        const __updateFullScreenLabel = () => {
            const isFullScreen = !!document.fullscreenElement;

            // 更新按钮标题
            if (__fullScreenBtnEl) {
                __fullScreenBtnEl.title = isFullScreen ? '退出全屏' : '全屏显示';
            }

            // 更新全屏样式类
            if (isFullScreen) {
                document.body.classList.add('fullscreen-mode');
            } else {
                document.body.classList.remove('fullscreen-mode');
            }
        };
        // 初始化与状态变更监听（ESC/系统触发退出时也能更新）
        document.addEventListener('fullscreenchange', __updateFullScreenLabel);
        __updateFullScreenLabel();

        document.getElementById('fullScreenBtn').addEventListener('click', function () {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
            // 点击后立即刷新文案，避免部分平台事件延迟
            __updateFullScreenLabel();
        });

        // 退出登录功能
        const logoutBtn = document.getElementById('logoutBtn');
        if (logoutBtn) {
            logoutBtn.addEventListener('click', async function () {
                // 关闭下拉菜单
                window.__hideAllDropdowns && window.__hideAllDropdowns();

                if (confirm('确认退出登录？')) {
                    try {
                        const res = await fetch('/auth/logout', { method: 'POST' });
                        const data = await res.json();
                        if (data.status !== 'fail') {
                            window.location.href = '/Login';
                        } else {
                            alert('退出失败: ' + (data.message || '未知错误'));
                        }
                    } catch (err) {
                        console.error('Logout error:', err);
                        window.location.href = '/Login'; // Fallback
                    }
                }
            });
        }
        // 全局变量
        let isResizing = false;
        let uploadedImages = [];
        let selectedImages = new Set();
        let draggedItem = null;
        const maxImages = 4;
        let detectedUrls = [];

        async function loadHeicScript() {
            if (typeof heic2any !== 'undefined') return;
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = '/js/heic2any.min.js';
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        // 初始化
        document.addEventListener('DOMContentLoaded', function () {
            initTheme();
            initResizable();
            initTextEditor();
            initImageUpload();
            initButtons();
            initExport();
            initModal();
            initIPC();
            initZoomControls();

            // Global context menu for images - REMOVED to use custom menu
            /* 
            document.addEventListener('contextmenu', function(e) {
                if (e.target.tagName === 'IMG') {
                    // ...
                }
            }); 
            */
        });

        // Zoom & Font Size Logic
        function initZoomControls() {
            let currentZoom = 100;
            // Use scale multiplier based on 16px base
            let currentFontScale = 1.0; // multiplier: 0.8,0.9,1.0,1.1...
            const BASE_FONT_PX = 16;
            const textInput = document.getElementById('textInput');
            const contentArea = document.querySelector('.content-area');

            // Font Size (scale-based)
            const updateFontDisplay = () => {
                const pxVal = (BASE_FONT_PX * currentFontScale);
                const pxStr = pxVal + 'px';
                const scaleStr = currentFontScale.toFixed(1);

                // 更新全局字体缩放变量
                document.documentElement.style.setProperty('--font-scale', scaleStr);

                // Update More Menu display (show only multiplier)
                const fontVal = document.getElementById('fontVal');
                if (fontVal) fontVal.textContent = scaleStr;

                // Update Edit Toolbar display if present (show multiplier)
                const editFontVal = document.getElementById('editFontVal');
                if (editFontVal) editFontVal.textContent = scaleStr;

                localStorage.setItem('editorFontScale', currentFontScale);
            };

            // Load saved font scale
            const savedScale = localStorage.getItem('editorFontScale');
            if (savedScale) {
                const s = parseFloat(savedScale);
                if (!isNaN(s)) currentFontScale = s;
                updateFontDisplay();
            } else {
                updateFontDisplay();
            }

            // More Menu Controls: step by 0.1, show only multiplier
            const incBtn = document.getElementById('fontInc');
            const decBtn = document.getElementById('fontDec');
            if (incBtn) incBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (currentFontScale < 2.0) {
                    currentFontScale = Math.round((currentFontScale + 0.1) * 10) / 10;
                    updateFontDisplay();
                }
            });
            if (decBtn) decBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (currentFontScale > 0.8) {
                    currentFontScale = Math.round((currentFontScale - 0.1) * 10) / 10;
                    updateFontDisplay();
                }
            });

            // Edit Toolbar Controls - Local Selection
            function getSelectionFontSize() {
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    let node = range.commonAncestorContainer;

                    if (node.nodeType === 1 && range.startContainer === node && range.endContainer === node) {
                        const child = node.childNodes[range.startOffset];
                        if (child && child.nodeType === 1 && range.endOffset - range.startOffset === 1) {
                            return parseFloat(window.getComputedStyle(child).fontSize);
                        }
                    }

                    if (node.nodeType === 3) node = node.parentNode;
                    if (document.getElementById('textInput').contains(node)) {
                        return parseFloat(window.getComputedStyle(node).fontSize);
                    }
                }
                // return current global font in px
                return BASE_FONT_PX * currentFontScale;
            }

            function applySelectionFontSize(newSize) {
                const textInput = document.getElementById('textInput');
                textInput.focus();

                // Use fontName hack to wrap selection
                const uuid = 'fs-' + Date.now();
                document.execCommand('fontName', false, uuid);

                const fonts = textInput.querySelectorAll(`font[face="${uuid}"]`);
                const newSpans = [];
                fonts.forEach(font => {
                    const span = document.createElement('span');
                    span.style.fontSize = newSize + 'px';
                    while (font.firstChild) {
                        span.appendChild(font.firstChild);
                    }
                    font.parentNode.replaceChild(span, font);
                    newSpans.push(span);
                });

                // Restore selection to cover the newly created spans
                if (newSpans.length > 0) {
                    const range = document.createRange();
                    range.setStartBefore(newSpans[0]);
                    range.setEndAfter(newSpans[newSpans.length - 1]);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                }
            }

            function updateFontButtonsState() {
                const editFontInc = document.getElementById('editFontInc');
                const editFontDec = document.getElementById('editFontDec');
                if (!editFontInc || !editFontDec) return;

                const sel = window.getSelection();
                const textInput = document.getElementById('textInput');
                let isDisabled = true;

                if (sel.rangeCount > 0 && !sel.isCollapsed) {
                    // Check if selection intersects with textInput
                    let node = sel.anchorNode;
                    if (node.nodeType === 3) node = node.parentNode;

                    // Fix: Ensure we are checking against the textInput element correctly
                    // Use closest to find if the node is inside textInput
                    if (node.nodeType === 1 && node.closest('#textInput')) {
                        isDisabled = false;
                    } else if (node.parentNode && node.parentNode.closest && node.parentNode.closest('#textInput')) {
                        isDisabled = false;
                    } else if (textInput.contains(node)) {
                        isDisabled = false;
                    }
                }

                editFontInc.disabled = isDisabled;
                editFontDec.disabled = isDisabled;
                editFontInc.style.opacity = isDisabled ? '0.5' : '1';
                editFontDec.style.opacity = isDisabled ? '0.5' : '1';
                editFontInc.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
                editFontDec.style.cursor = isDisabled ? 'not-allowed' : 'pointer';
            }

            const editFontInc = document.getElementById('editFontInc');
            if (editFontInc) {
                editFontInc.addEventListener('mousedown', e => e.preventDefault());
                editFontInc.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (editFontInc.disabled) return;
                    const current = getSelectionFontSize();
                    if (current < 72) {
                        applySelectionFontSize(current + 2);
                    }
                });
            }

            const editFontDec = document.getElementById('editFontDec');
            if (editFontDec) {
                editFontDec.addEventListener('mousedown', e => e.preventDefault());
                editFontDec.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (editFontDec.disabled) return;
                    const current = getSelectionFontSize();
                    if (current > 12) {
                        applySelectionFontSize(current - 2);
                    }
                });
            }

            // Update font size display on selection change
            document.addEventListener('selectionchange', () => {
                if (document.body.classList.contains('edit-mode')) {
                    updateFontButtonsState();
                }
            });

            // Initial check
            updateFontButtonsState();

            // UI Zoom removed
            // Browser Toggle logic removed
        }

        // 主题切换
        function initTheme() {
            const themeBtn = document.getElementById('themeBtn');
            const themeIconLight = document.getElementById('themeIconLight');
            const themeIconDark = document.getElementById('themeIconDark');

            // 检查系统主题偏好
            const systemDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            // 优先使用本地存储的主题，如果没有则跟随系统
            const savedTheme = localStorage.getItem('theme');
            const isDark = savedTheme ? (savedTheme === 'dark') : systemDark;

            function updateThemeIcon(isDark) {
                if (isDark) {
                    themeIconLight.style.display = 'none';
                    themeIconDark.style.display = 'inline';
                } else {
                    themeIconLight.style.display = 'inline';
                    themeIconDark.style.display = 'none';
                }
            }

            // 应用初始主题
            if (isDark) {
                document.documentElement.setAttribute('data-theme', 'dark');
                updateThemeIcon(true);
            } else {
                document.documentElement.setAttribute('data-theme', 'light');
                updateThemeIcon(false);
            }

            // 监听系统主题变化
            if (window.matchMedia) {
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                    // 只有在用户没有手动设置过主题的情况下才跟随系统变化
                    if (!localStorage.getItem('theme')) {
                        const newIsDark = e.matches;
                        if (newIsDark) {
                            document.documentElement.setAttribute('data-theme', 'dark');
                            updateThemeIcon(true);
                        } else {
                            document.documentElement.setAttribute('data-theme', 'light');
                            updateThemeIcon(false);
                        }
                    }
                });
            }
            themeBtn.addEventListener('click', function () {
                const currentTheme = document.documentElement.getAttribute('data-theme');
                const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
                const isDarkMode = newTheme === 'dark';

                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                updateThemeIcon(isDarkMode);

                if (typeof applyDynamicTheme === 'function') applyDynamicTheme();

                showToast(`已切换到${isDarkMode ? '深色' : '浅色'}模式`, 'success');
            });
        }

        // 可调整大小的分隔线
        let currentPercentage = 50;
        function initResizable() {
            const resizer = document.getElementById('resizer');
            const leftPanel = document.getElementById('leftPanel');
            const rightPanel = document.getElementById('rightPanel');
            const container = document.getElementById('mainLayout');
            const leftMask = document.getElementById('leftMask');
            const rightMask = document.getElementById('rightMask');
            const exitDetectionBtn = document.getElementById('exitDetectionBtn');
            let isResizing = false;
            let lastClientX = 0;

            // Exit Detection Fullscreen
            if (exitDetectionBtn) {
                exitDetectionBtn.addEventListener('click', () => {
                    // Remove class immediately to prevent infinite loop with toggleSearchResults
                    document.body.classList.remove('detection-fullscreen');

                    // Close search results if open - user explicitly wants to restore layout
                    toggleSearchResults(false);

                    // Smooth transition back
                    leftPanel.style.flex = `1`;
                    rightPanel.style.flex = `1`;

                    currentPercentage = 50;
                });
            }

            function handleResizeMove(clientX) {
                const containerRect = container.getBoundingClientRect();
                let leftWidth = clientX - containerRect.left;

                // 异步处理逻辑：根据拖动方向显示模糊遮罩
                // 向右拖动 (clientX > lastClientX) -> 扩展左侧，遮挡右侧
                // 向左拖动 (clientX < lastClientX) -> 扩展右侧，遮挡左侧
                if (clientX > lastClientX) {
                    if (rightMask) {
                        rightMask.style.opacity = 1;
                        rightMask.style.pointerEvents = 'auto';
                    }
                    if (leftMask) {
                        leftMask.style.opacity = 0;
                        leftMask.style.pointerEvents = 'none';
                    }
                    // 冻结右侧内容：锁定宽度防止重排
                    const resultContent = rightPanel.querySelector('.result-content');
                    if (resultContent && !rightPanel.dataset.frozen) {
                        const currentWidth = rightPanel.clientWidth;
                        resultContent.style.width = currentWidth + 'px';
                        rightPanel.style.overflow = 'hidden';
                        rightPanel.dataset.frozen = 'true';
                    }
                    // 解冻左侧
                    const leftContent = leftPanel.querySelector('.left-content');
                    if (leftContent && leftPanel.dataset.frozen) {
                        leftContent.style.width = '';
                        leftPanel.style.overflow = '';
                        delete leftPanel.dataset.frozen;
                    }
                } else if (clientX < lastClientX) {
                    if (leftMask) {
                        leftMask.style.opacity = 1;
                        leftMask.style.pointerEvents = 'auto';
                    }
                    if (rightMask) {
                        rightMask.style.opacity = 0;
                        rightMask.style.pointerEvents = 'none';
                    }
                    // 冻结左侧内容：锁定宽度防止重排
                    const leftContent = leftPanel.querySelector('.left-content');
                    if (leftContent && !leftPanel.dataset.frozen) {
                        const currentWidth = leftPanel.clientWidth;
                        leftContent.style.width = currentWidth + 'px';
                        leftPanel.style.overflow = 'hidden';
                        leftPanel.dataset.frozen = 'true';
                    }
                    // 解冻右侧
                    const resultContent = rightPanel.querySelector('.result-content');
                    if (resultContent && rightPanel.dataset.frozen) {
                        resultContent.style.width = '';
                        rightPanel.style.overflow = '';
                        delete rightPanel.dataset.frozen;
                    }
                }

                if (typeof isBatchMode !== 'undefined' && isBatchMode) {
                    const maxLeftWidth = containerRect.width * 0.6;
                    if (leftWidth > maxLeftWidth) {
                        leftWidth = maxLeftWidth;
                    }
                }

                leftWidth = Math.max(0, Math.min(containerRect.width, leftWidth));
                currentPercentage = (leftWidth / containerRect.width) * 100;

                lastClientX = clientX;

                // Use percentage for left panel to maintain ratio on resize
                leftPanel.style.flex = `0 0 ${currentPercentage}%`;
                rightPanel.style.flex = `1`;
            }

            // Mouse Events
            resizer.addEventListener('mousedown', function (e) {
                isResizing = true;
                lastClientX = e.clientX;
                initialMouseX = e.clientX;
                document.body.classList.add('resizing');
                document.body.style.cursor = 'col-resize';

                // 拖动分隔线时立即关闭搜索页面
                if (typeof toggleSearchResults === 'function') {
                    toggleSearchResults(false);
                }
            });

            document.addEventListener('mousemove', function (e) {
                if (!isResizing) return;
                e.preventDefault();
                handleResizeMove(e.clientX);
            });

            document.addEventListener('mouseup', function () {
                if (isResizing) {
                    // 两侧页面实际大小判断：进入全屏编辑或结果页面
                    const leftWidth = leftPanel.offsetWidth;
                    const rightWidth = rightPanel.offsetWidth;
                    const threshold = 380; // 阈值设定为 380px

                    isResizing = false;
                    document.body.classList.remove('resizing');
                    document.body.style.cursor = 'default';

                    // 重置遮罩和滚动效果
                    if (leftMask) {
                        leftMask.style.opacity = 0;
                        leftMask.style.pointerEvents = 'none';
                    }
                    if (rightMask) {
                        rightMask.style.opacity = 0;
                        rightMask.style.pointerEvents = 'none';
                    }

                    // 解冻所有面板
                    const leftContent = leftPanel.querySelector('.left-content');
                    if (leftContent) leftContent.style.width = '';
                    const resultContent = rightPanel.querySelector('.result-content');
                    if (resultContent) resultContent.style.width = '';

                    leftPanel.style.overflow = '';
                    rightPanel.style.overflow = '';
                    delete leftPanel.dataset.frozen;
                    delete rightPanel.dataset.frozen;

                    if (leftWidth < threshold) {
                        // 左侧编辑器太窄，自动进入结果全屏
                        document.body.classList.remove('edit-mode'); // 互斥处理
                        document.body.classList.add('detection-fullscreen');
                    } else if (rightWidth < threshold) {
                        // 右侧结果栏太窄，自动进入编辑全屏
                        document.body.classList.remove('detection-fullscreen'); // 互斥处理
                        const editBtn = document.getElementById('editBtn');
                        if (editBtn && !document.body.classList.contains('edit-mode')) {
                            editBtn.click();
                        }
                    }
                }
            });

            // Touch Events (复用逻辑)
            resizer.addEventListener('touchstart', function (e) {
                isResizing = true;
                lastClientX = e.touches[0].clientX;
                document.body.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', function (e) {
                if (!isResizing) return;
                e.preventDefault();
                handleResizeMove(e.touches[0].clientX);
            }, { passive: false });

            document.addEventListener('touchend', function () {
                if (isResizing) {
                    // 两侧页面实际大小判断：进入全屏编辑或结果页面
                    const leftWidth = leftPanel.offsetWidth;
                    const rightWidth = rightPanel.offsetWidth;
                    const threshold = 280;

                    isResizing = false;
                    document.body.classList.remove('resizing');
                    document.body.style.cursor = 'default';

                    // 重置遮罩和滚动效果
                    if (leftMask) {
                        leftMask.style.opacity = 0;
                        leftMask.style.pointerEvents = 'none';
                    }
                    if (rightMask) {
                        rightMask.style.opacity = 0;
                        rightMask.style.pointerEvents = 'none';
                    }

                    // 解冻所有面板
                    const leftContent = leftPanel.querySelector('.left-content');
                    if (leftContent) leftContent.style.width = '';
                    const resultContent = rightPanel.querySelector('.result-content');
                    if (resultContent) resultContent.style.width = '';

                    leftPanel.style.overflow = '';
                    rightPanel.style.overflow = '';
                    delete leftPanel.dataset.frozen;
                    delete rightPanel.dataset.frozen;

                    if (leftWidth < threshold) {
                        document.body.classList.remove('edit-mode');
                        document.body.classList.add('detection-fullscreen');
                    } else if (rightWidth < threshold) {
                        document.body.classList.remove('detection-fullscreen');
                        const editBtn = document.getElementById('editBtn');
                        if (editBtn && !document.body.classList.contains('edit-mode')) {
                            editBtn.click();
                        }
                    }
                }
            });
        }

        // 更新编辑器统计信息
        function updateEditorStats() {
            const textInput = document.getElementById('textInput');
            const wordCountEl = document.getElementById('wordCount');
            const imageCountEl = document.getElementById('imageCount');
            const detectBtn = document.getElementById('detectBtn');

            if (textInput && wordCountEl) {
                const text = textInput.innerText || '';
                // 简单字数统计：去除空白字符后的长度
                const count = text.replace(/\s+/g, '').length;
                wordCountEl.textContent = `${count} / 10000 字`;

                if (count > 10000) {
                    wordCountEl.style.color = 'var(--danger-color)';
                    if (detectBtn) {
                        detectBtn.disabled = true;
                        detectBtn.style.opacity = '0.5';
                        detectBtn.style.pointerEvents = 'none';
                    }
                } else {
                    if (count > 9000) {
                        wordCountEl.style.color = 'var(--warning-color)';
                    } else {
                        wordCountEl.style.color = '';
                    }
                    if (detectBtn && (!document.body.classList.contains('processing'))) {
                        detectBtn.disabled = false;
                        detectBtn.style.opacity = '1';
                        detectBtn.style.pointerEvents = 'auto';
                    }
                }
            }

            if (imageCountEl) {
                imageCountEl.textContent = `${uploadedImages.length} 图片`;
            }

            updateClearButtonState();
        }

        // Update Clear Button State
        function updateClearButtonState() {
            const clearBtn = document.getElementById('clearBtn');
            if (!clearBtn) return;

            const textInput = document.getElementById('textInput');
            const hasText = textInput && textInput.innerText.trim().length > 0;
            const hasImages = typeof uploadedImages !== 'undefined' && uploadedImages.length > 0;

            // Check if right panel is in initial state (ready)
            const initialState = document.getElementById('initialState');
            const isInitialState = initialState && getComputedStyle(initialState).display !== 'none';

            // Disable if (No Text AND No Images AND Is Initial State)
            const shouldDisable = (!hasText && !hasImages) && isInitialState;

            clearBtn.disabled = shouldDisable;
            if (shouldDisable) {
                clearBtn.classList.add('disabled');
                clearBtn.style.opacity = '0.4';
                clearBtn.style.pointerEvents = 'none';
            } else {
                clearBtn.classList.remove('disabled');
                clearBtn.style.opacity = '1';
                clearBtn.style.pointerEvents = 'auto';
            }
        }

        // 文本编辑器
        function initTextEditor() {
            const textInput = document.getElementById('textInput');
            const contentArea = document.querySelector('.content-area');
            const editBtn = document.getElementById('editBtn');
            const closeEditBtn = document.getElementById('closeEditBtn');
            // const editOptions = document.getElementById('editOptions'); // Controlled via CSS now

            // 粘贴纯文本处理
            textInput.addEventListener('paste', function (e) {
                e.preventDefault();
                let text = (e.clipboardData || window.clipboardData).getData('text/plain');
                if (!text) return;

                e.stopPropagation(); // 阻止冒泡，表示文本已处理

                // 检查字数限制
                const currentLength = this.innerText.length; // innerText is more accurate for visible text
                const maxLength = 10000;

                if (currentLength >= maxLength) {
                    showToast('字数已超过最大限制 (10000字)', 'warning');
                    return;
                }

                if (currentLength + text.length > maxLength) {
                    const remaining = maxLength - currentLength;
                    if (remaining > 0) {
                        // 截断文本
                        text = text.substring(0, remaining);
                        document.execCommand('insertText', false, text);
                    }
                    showToast('字数已超过最大限制 (10000字)', 'warning');
                } else {
                    document.execCommand('insertText', false, text);
                }
            });

            // 键盘输入限制
            textInput.addEventListener('keydown', function (e) {
                // 允许的功能键
                const allowedKeys = [
                    'Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown',
                    'Home', 'End', 'PageUp', 'PageDown', 'Tab'
                ];

                // 允许组合键 (Ctrl/Cmd + A/C/V/X/Z)
                if (e.ctrlKey || e.metaKey) return;

                if (allowedKeys.includes(e.key)) return;

                if (this.innerText.length >= 10000) {
                    // 如果有选中文本，允许输入（因为会替换）
                    const selection = window.getSelection();
                    if (selection.toString().length > 0) return;

                    e.preventDefault();
                    showToast('字数已超过最大限制 (10000字)', 'warning');
                }
            });

            // 自动识别链接与字数统计
            textInput.addEventListener('input', function () {
                updateEditorStats();
                const text = this.innerText;
                const urlRegex = /(https?:\/\/|www\.)[^\s<]+/g;
                const matches = text.match(urlRegex);

                if (matches && matches.length > 0) {
                    // 检查是否有新的链接
                    const newUrls = matches.filter(url => !detectedUrls.includes(url));
                    if (newUrls.length > 0) {
                        detectedUrls = [...detectedUrls, ...newUrls];
                        showToast(`检测到 ${newUrls.length} 个网址链接`, 'info');
                    }
                }
            });

            // Preserve scroll position when toggling edit mode
            const editScrollState = { content: 0, text: 0 };
            const captureEditScrollState = () => {
                if (contentArea) editScrollState.content = contentArea.scrollTop;
                if (textInput) editScrollState.text = textInput.scrollTop;
            };
            const restoreEditScrollState = () => {
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        if (contentArea) contentArea.scrollTop = editScrollState.content;
                        if (textInput) textInput.scrollTop = editScrollState.text;
                    });
                });
            };

            // Toggle Edit Mode
            function toggleEditMode(active) {
                // Preserve scroll positions
                const textScrollBefore = textInput.scrollTop;
                const contentScrollBefore = contentArea.scrollTop;
                const leftPanel = document.getElementById('leftPanel');
                const rightPanel = document.getElementById('rightPanel');
                const toolbar = document.querySelector('.toolbar');
                const collapsedIndicator = document.getElementById('collapsedIndicator');
                const batchToggle = document.getElementById('batchModeToggle');

                if (active) {
                    document.body.classList.add('edit-mode');
                    editBtn.classList.add('active');
                    if (batchToggle) batchToggle.classList.add('disabled');
                    textInput.focus();

                    // 文字移动动画
                    requestAnimationFrame(() => {
                        contentArea.scrollTop = textScrollBefore;
                        textInput.scrollTop = textScrollBefore;
                    });
                } else {
                    document.body.classList.remove('edit-mode');
                    editBtn.classList.remove('active');
                    if (batchToggle) batchToggle.classList.remove('disabled');

                    // Reset divider positions (Restore to 50/50)
                    if (leftPanel && rightPanel) {
                        leftPanel.style.flex = '1';
                        rightPanel.style.flex = '1';
                        
                        if (toolbar) {
                            toolbar.classList.remove('hidden');
                            toolbar.style.setProperty('--toolbar-gap', '12px'); 
                        }
                        if (collapsedIndicator) collapsedIndicator.classList.remove('visible');
                    }

                    // Restore the original text scroll
                    requestAnimationFrame(() => {
                        textInput.scrollTop = contentScrollBefore;
                        contentArea.scrollTop = 0;
                    });
                }
            }

            // 编辑选项切换
            editBtn.addEventListener('click', function () {
                const isEditMode = document.body.classList.contains('edit-mode');
                toggleEditMode(!isEditMode);
            });

            if (closeEditBtn) {
                closeEditBtn.addEventListener('click', function () {
                    toggleEditMode(false);
                });
            }

            // 编辑按钮功能（通用 data-command）
            document.querySelectorAll('.edit-btn:not(.close-edit-btn)').forEach(btn => {
                btn.addEventListener('click', function () {
                    const command = this.dataset.command;
                    if (command) {
                        document.execCommand(command, false, null);
                        textInput.focus();
                        refreshUndoRedo && refreshUndoRedo();
                    }
                });
            });

            // New Toolbar Buttons Logic
            const editPasteBtn = document.getElementById('editPasteBtn');
            const editCutBtn = document.getElementById('editCutBtn');
            const editFormatPainterBtn = document.getElementById('editFormatPainterBtn');
            const editHeadingBtn = document.getElementById('editHeadingBtn');
            const editAddImageBtn = document.getElementById('editAddImageBtn');
            const headingDropdown = document.getElementById('headingDropdown');
            const editUndoBtn = document.getElementById('editUndoBtn');
            const editRedoBtn = document.getElementById('editRedoBtn');
            const editFormatBtn = document.getElementById('editFormatBtn');
            const formatDropdown = document.getElementById('formatDropdown');

            if (editPasteBtn) {
                editPasteBtn.addEventListener('click', async () => {
                    await handlePaste();
                    textInput.focus();
                });
            }

            const editOptionsPasteBtn = document.getElementById('editOptionsPasteBtn');
            if (editOptionsPasteBtn) {
                editOptionsPasteBtn.addEventListener('click', async () => {
                    await handlePaste();
                    textInput.focus();
                });
            }

            if (editCutBtn) {
                editCutBtn.addEventListener('click', () => {
                    document.execCommand('cut');
                    textInput.focus();
                    refreshUndoRedo();
                });
            }

            if (editFormatPainterBtn) {
                editFormatPainterBtn.addEventListener('click', () => {
                    document.execCommand('removeFormat', false, null);
                    textInput.focus();
                    refreshUndoRedo && refreshUndoRedo();
                });
            }

            // 撤销/重做逻辑
            function refreshUndoRedo() {
                if (!editUndoBtn || !editRedoBtn) return;
                let canUndo = false, canRedo = false;
                try {
                    canUndo = document.queryCommandEnabled('undo');
                    canRedo = document.queryCommandEnabled('redo');
                } catch (e) {
                    // ignore
                }
                editUndoBtn.disabled = !canUndo;
                editRedoBtn.disabled = !canRedo;

                if (editCutBtn) {
                    let canCut = false;
                    try {
                        canCut = document.queryCommandEnabled('cut');
                    } catch (e) { }
                    // Fallback: check selection if queryCommandEnabled returns false (sometimes unreliable)
                    if (!canCut) {
                        const sel = window.getSelection();
                        canCut = sel && sel.toString().length > 0;
                    }
                    editCutBtn.disabled = !canCut;
                }
            }
            if (editUndoBtn) {
                editUndoBtn.addEventListener('click', () => {
                    textInput.focus();
                    document.execCommand('undo');
                    refreshUndoRedo();
                });
            }
            if (editRedoBtn) {
                editRedoBtn.addEventListener('click', () => {
                    textInput.focus();
                    document.execCommand('redo');
                    refreshUndoRedo();
                });
            }
            ['input', 'keyup', 'mouseup', 'paste', 'cut'].forEach(ev => {
                textInput.addEventListener(ev, () => {
                    refreshUndoRedo();
                });
            });
            textInput.addEventListener('focus', refreshUndoRedo);
            document.addEventListener('selectionchange', refreshUndoRedo);

            // Heading Dropdown Logic
            if (editHeadingBtn && headingDropdown) {
                editHeadingBtn.addEventListener('click', (e) => {
                    // e.stopPropagation(); // Removed to allow other dropdowns to close
                    headingDropdown.classList.toggle('show');
                });

                // Dropdown items click
                headingDropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        // e.stopPropagation();
                        const cmd = item.dataset.cmd;
                        const val = item.dataset.val;
                        document.execCommand(cmd, false, val);
                        headingDropdown.classList.remove('show');
                        textInput.focus();
                    });
                });

                // Close dropdown when clicking outside
                document.addEventListener('click', (e) => {
                    if (!editHeadingBtn.contains(e.target) && !headingDropdown.contains(e.target)) {
                        headingDropdown.classList.remove('show');
                    }
                });
            }

            // 文本格式菜单逻辑
            if (editFormatBtn && formatDropdown) {
                editFormatBtn.addEventListener('click', (e) => {
                    // e.stopPropagation(); // Removed
                    formatDropdown.classList.toggle('show');
                });
                // 在菜单内点击格式按钮后自动收起
                formatDropdown.addEventListener('click', (e) => {
                    const item = e.target.closest('.dropdown-item');
                    if (item && item.dataset && item.dataset.command) {
                        document.execCommand(item.dataset.command, false, null);
                        textInput.focus();
                        refreshUndoRedo && refreshUndoRedo();
                        // 延迟以便 execCommand 先执行
                        setTimeout(() => formatDropdown.classList.remove('show'), 0);
                    }
                });
                // 点击外部关闭
                document.addEventListener('click', (e) => {
                    if (!editFormatBtn.contains(e.target) && !formatDropdown.contains(e.target)) {
                        formatDropdown.classList.remove('show');
                    }
                });
            }

            // Prevent overlapping dropdowns on hover
            document.querySelectorAll('.edit-btn-group').forEach(group => {
                group.addEventListener('mouseenter', () => {
                    // Close all other open dropdowns in the toolbar
                    document.querySelectorAll('.dropdown-menu.show').forEach(menu => {
                        if (!group.contains(menu) && menu.id !== 'moreDropdown') {
                            menu.classList.remove('show');
                        }
                    });
                });
            });

            if (editAddImageBtn) {
                editAddImageBtn.addEventListener('click', () => {
                    document.getElementById('fileInput').click();
                });
            }

            // Context Menu Logic
            const contextMenu = document.getElementById('editContextMenu');

            // Submenu Logic (Floating)
            let activeSubmenu = null;
            let submenuCloseTimer = null;

            function closeSubmenu() {
                if (activeSubmenu) {
                    const parentText = activeSubmenu.dataset.parent;
                    document.querySelectorAll('.context-menu-item').forEach(i => {
                        if (i.innerText === parentText) {
                            i.classList.remove('has-submenu-open');
                        }
                    });
                    activeSubmenu.remove();
                    activeSubmenu = null;
                }
            }

            document.querySelectorAll('.context-menu-item').forEach(item => {
                const originalSubmenu = item.querySelector('.context-submenu');

                item.addEventListener('mouseenter', () => {
                    if (submenuCloseTimer) {
                        clearTimeout(submenuCloseTimer);
                        submenuCloseTimer = null;
                    }

                    // If hovering a different item, close existing submenu
                    if (activeSubmenu && activeSubmenu.dataset.parent !== item.innerText) {
                        closeSubmenu();
                    }

                    if (originalSubmenu) {
                        if (activeSubmenu) return; // Already open

                        item.classList.add('has-submenu-open');

                        // Create floating submenu
                        const floating = document.createElement('div');
                        floating.className = 'floating-submenu';
                        floating.innerHTML = originalSubmenu.innerHTML;
                        floating.dataset.parent = item.innerText;

                        document.body.appendChild(floating);
                        activeSubmenu = floating;

                        // Positioning
                        const rect = item.getBoundingClientRect();
                        const winWidth = window.innerWidth;
                        const winHeight = window.innerHeight;

                        // Use offsetWidth/Height to ignore scaling transformations
                        const subWidth = floating.offsetWidth || 160;
                        const subHeight = floating.offsetHeight || 100;

                        let left = rect.right - 2; // Slight overlap
                        let top = rect.top - 6; // Align with item padding

                        // Horizontal flip
                        let isFlipped = false;
                        if (left + subWidth > winWidth - 10) {
                            left = rect.left - subWidth + 2;
                            isFlipped = true;
                        }

                        // Vertical adjustment
                        if (top + subHeight > winHeight - 10) {
                            top = winHeight - subHeight - 10;
                        }
                        if (top < 10) top = 10;

                        // Set transform origin for better animation
                        floating.style.transformOrigin = isFlipped ? 'right top' : 'left top';

                        floating.style.left = left + 'px';
                        floating.style.top = top + 'px';

                        // Events for floating menu
                        floating.addEventListener('mouseenter', () => {
                            if (submenuCloseTimer) {
                                clearTimeout(submenuCloseTimer);
                                submenuCloseTimer = null;
                            }
                        });

                        floating.addEventListener('mouseleave', () => {
                            submenuCloseTimer = setTimeout(closeSubmenu, 200);
                        });

                        // Re-bind click events
                        floating.querySelectorAll('.context-menu-item').forEach(subItem => {
                            subItem.addEventListener('click', (e) => {
                                e.stopPropagation();
                                if (subItem.dataset.cmd) {
                                    const cmd = subItem.dataset.cmd;
                                    const val = subItem.dataset.val || null;
                                    document.execCommand(cmd, false, val);
                                } else if (subItem.dataset.format) {
                                    if (typeof exportResult === 'function') {
                                        exportResult(subItem.dataset.format);
                                    }
                                }
                                closeSubmenu();
                                contextMenu.classList.remove('active');
                                const resultContextMenu = document.getElementById('resultContextMenu');
                                if (resultContextMenu) resultContextMenu.classList.remove('active');
                            });
                        });
                    }
                });

                item.addEventListener('mouseleave', () => {
                    submenuCloseTimer = setTimeout(closeSubmenu, 200);
                });
            });

            // Global context menu handler
            document.addEventListener('contextmenu', (e) => {
                // Close result context menu if open
                const resultContextMenu = document.getElementById('resultContextMenu');
                if (resultContextMenu) resultContextMenu.classList.remove('active');

                e.preventDefault(); // Always prevent default to block native menu

                // Close any open toolbar dropdowns
                document.querySelectorAll('.dropdown-menu.show').forEach(el => el.classList.remove('show'));

                // Determine context
                const isInput = e.target.closest('#textInput') || e.target.closest('.content-area');
                const isRightPanel = e.target.closest('.right-panel');
                const isImage = e.target.tagName === 'IMG';

                // Only show custom menu for main areas or images
                if (!isInput && !isRightPanel && !isImage) return;

                // Check if right panel is active (has result or preview)
                if (isRightPanel) {
                    const resultItem = document.getElementById('resultItem');
                    if (!resultItem.classList.contains('active')) return;
                }

                // If right clicking an image, clear any text selection
                if (isImage) {
                    window.getSelection().removeAllRanges();
                }

                // Selection Logic for Right Panel (Text only)
                if (isRightPanel && !isImage) {
                    // Clear left panel selection to avoid confusion
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        if (document.getElementById('textInput').contains(range.commonAncestorContainer)) {
                            selection.removeAllRanges();
                        }
                    }
                }

                // Get selected text for Search/GoTo
                const selectedText = window.getSelection().toString().trim();
                const isUrl = selectedText && /^(http|https):\/\/[^ "]+$/.test(selectedText);

                // Toggle items based on context
                const isEditMode = document.body.classList.contains('edit-mode');

                // Helper to show/hide
                const setDisplay = (id, show) => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = show ? 'flex' : 'none';
                };

                // Store target info
                contextMenu.dataset.targetType = isImage ? 'image' : (isInput ? 'input' : 'output');
                if (isImage) {
                    contextMenu.dataset.imageSrc = e.target.src;
                    contextMenu.currentElement = e.target;

                    // 获取图片ID以便正确删除
                    const item = e.target.closest('.image-preview-item');
                    if (item && item.dataset.id) {
                        contextMenu.dataset.imageId = item.dataset.id;
                    } else {
                        delete contextMenu.dataset.imageId;
                    }
                } else {
                    contextMenu.currentElement = null;
                    delete contextMenu.dataset.imageId;
                }

                if (isImage) {
                    // Image Context
                    setDisplay('ctxSearch', false);
                    setDisplay('ctxSearchSep', false);
                    setDisplay('ctxGoTo', false);

                    // Cut/Delete: Only in Input (Left Panel)
                    // For images, the image itself is the selection target
                    const isInputImage = isInput || e.target.closest('.image-preview-item');

                    setDisplay('ctxCut', isInputImage);
                    setDisplay('ctxDelete', isInputImage);

                    setDisplay('ctxCopy', true); // Copy Image
                    setDisplay('ctxSaveAs', true); // Save Image

                    // Paste: Allow pasting in image context (Left Panel)
                    setDisplay('ctxPaste', isInputImage);

                    setDisplay('ctxPastePlain', false);
                    setDisplay('ctxAddImage', false);
                    setDisplay('ctxSelectAll', false);

                    // Hide format groups
                    const formatGroups = contextMenu.querySelectorAll('.ctx-format-group');
                    formatGroups.forEach(el => el.style.display = 'none');

                } else {
                    // Text Context
                    // Search & GoTo
                    if (selectedText) {
                        const displayContent = selectedText.length > 16 ? selectedText.substring(0, 16) + '...' : selectedText;
                        document.getElementById('ctxSearchText').textContent = displayContent;

                        if (isUrl) {
                            document.getElementById('ctxGoToUrl').textContent = displayContent;
                            setDisplay('ctxGoTo', true);
                        } else {
                            setDisplay('ctxGoTo', false);
                        }

                        setDisplay('ctxSearch', true);
                        setDisplay('ctxSearchSep', true);
                    } else {
                        setDisplay('ctxSearch', false);
                        setDisplay('ctxGoTo', false);
                        setDisplay('ctxSearchSep', false);
                    }

                    // Cut/Delete: Only in Input AND when text is selected
                    setDisplay('ctxCut', isInput && !!selectedText);
                    setDisplay('ctxDelete', isInput && !!selectedText);

                    // Save As: Only for images
                    setDisplay('ctxSaveAs', false);

                    // Copy (Always show if text selected)
                    setDisplay('ctxCopy', !!selectedText);

                    // Paste & Format (Only for Input)
                    setDisplay('ctxPaste', isInput);
                    setDisplay('ctxPastePlain', isInput);
                    setDisplay('ctxAddImage', isInput);

                    // Format Groups (Only for Input + Edit Mode)
                    const formatGroups = contextMenu.querySelectorAll('.ctx-format-group');
                    formatGroups.forEach(el => {
                        el.style.display = (isInput && isEditMode) ? (el.classList.contains('context-menu-separator') ? 'block' : 'flex') : 'none';
                    });

                    // Select All
                    setDisplay('ctxSelectAll', true);
                    const selectAllItem = document.getElementById('ctxSelectAll');
                    if (isInput) {
                        const textInput = document.getElementById('textInput');
                        const hasContent = textInput.innerText.trim().length > 0 || textInput.querySelector('img');
                        if (!hasContent) {
                            selectAllItem.classList.add('disabled');
                        } else {
                            selectAllItem.classList.remove('disabled');
                        }
                    } else {
                        selectAllItem.classList.remove('disabled');
                    }
                }

                // Position menu (Smart Positioning)
                const x = e.clientX;
                const y = e.clientY;
                const winWidth = window.innerWidth;
                const winHeight = window.innerHeight;

                // Reset max-height before measuring
                contextMenu.style.maxHeight = '';
                contextMenu.style.overflowY = '';

                // Measure height
                contextMenu.style.visibility = 'hidden';
                contextMenu.classList.add('active');
                const menuHeight = contextMenu.offsetHeight;
                const menuWidth = contextMenu.offsetWidth;
                contextMenu.classList.remove('active');
                contextMenu.style.visibility = 'visible';

                let top = y;
                let left = x;

                // Flip vertically if near bottom
                if (y + menuHeight > winHeight) {
                    top = y - menuHeight;
                }
                // Flip horizontally if near right
                if (x + menuWidth > winWidth) {
                    left = winWidth - menuWidth - 10;
                }

                // Ensure menu stays within viewport bounds
                // Avoid overlapping with custom title bar (height 32px)
                if (top < 35) top = 35;
                if (left < 10) left = 10;

                // Check if it still overflows bottom
                if (top + menuHeight > winHeight) {
                    // If it's too tall, align to bottom or top depending on which has more space
                    if (winHeight - menuHeight > 0) {
                        top = winHeight - menuHeight - 10;
                        if (top < 35) top = 35; // Re-check top bound
                    } else {
                        top = 35; // Pin to top (below title bar)
                        // Enable scrolling
                        contextMenu.style.maxHeight = (winHeight - 45) + 'px'; // 35px top + 10px bottom padding
                        contextMenu.style.overflowY = 'auto';
                    }
                }

                contextMenu.style.left = `${left}px`;
                contextMenu.style.top = `${top}px`;
                contextMenu.classList.add('active');

                // Check clipboard content to update Paste Plain Text state
                if (isInput) {
                    const pastePlainItem = document.getElementById('ctxPastePlain');
                    // Reset state first
                    pastePlainItem.classList.remove('disabled');

                    if (navigator.clipboard && navigator.clipboard.read) {
                        navigator.clipboard.read().then(items => {
                            const hasImage = items.some(item => item.types.some(type => type.startsWith('image/')));
                            if (hasImage) {
                                pastePlainItem.classList.add('disabled');
                            }
                        }).catch(err => {
                            console.warn('Clipboard check failed:', err);
                        });
                    }
                }

                // Check submenu positioning
                const submenus = contextMenu.querySelectorAll('.context-submenu');
                submenus.forEach(submenu => {
                    // Reset first
                    submenu.classList.remove('left-side');

                    // Check if submenu would go off screen
                    // We estimate submenu width as 160px (min-width) + padding
                    const submenuWidth = 180;
                    const parentRect = contextMenu.getBoundingClientRect();

                    if (parentRect.right + submenuWidth > winWidth) {
                        submenu.classList.add('left-side');
                    }
                });
            });

            // Hide context menu on click elsewhere
            const closeMenus = (e) => {
                // Check if click is inside context menu OR inside the active floating submenu
                const inContextMenu = contextMenu.contains(e.target);
                const inSubmenu = activeSubmenu && activeSubmenu.contains(e.target);

                if (!inContextMenu && !inSubmenu) {
                    contextMenu.classList.remove('active');
                    closeSubmenu(); // Close submenu too
                }

                const resultContextMenu = document.getElementById('resultContextMenu');
                if (resultContextMenu && !resultContextMenu.contains(e.target)) {
                    resultContextMenu.classList.remove('active');
                }
            };

            document.addEventListener('pointerdown', closeMenus);
            window.addEventListener('blur', () => {
                contextMenu.classList.remove('active');
                const resultContextMenu = document.getElementById('resultContextMenu');
                if (resultContextMenu) resultContextMenu.classList.remove('active');
            });
            window.addEventListener('resize', () => {
                contextMenu.classList.remove('active');
                const resultContextMenu = document.getElementById('resultContextMenu');
                if (resultContextMenu) resultContextMenu.classList.remove('active');
            });

            // Context Menu Actions
            document.getElementById('ctxSearch').addEventListener('click', () => {
                const text = window.getSelection().toString().trim();
                if (text) {
                    // Use default browser search or specific engine
                    const url = `https://www.bing.com/search?q=${encodeURIComponent(text)}`;
                    window.open(url, '_blank');
                }
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxGoTo').addEventListener('click', () => {
                const text = window.getSelection().toString().trim();
                if (text) {
                    window.open(text, '_blank');
                }
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxCopy').addEventListener('click', async () => {
                if (contextMenu.dataset.targetType === 'image') {
                    const src = contextMenu.dataset.imageSrc;
                    try {
                        const response = await fetch(src);
                        const blob = await response.blob();
                        await navigator.clipboard.write([
                            new ClipboardItem({
                                [blob.type]: blob
                            })
                        ]);
                        showToast('图片已复制', 'success');
                    } catch (err) {
                        console.error('Copy failed', err);
                        showToast('复制图片失败', 'error');
                    }
                } else {
                    const text = window.getSelection().toString();
                    if (text) {
                        try {
                            await navigator.clipboard.writeText(text);
                            showToast('已复制到剪贴板', 'success');
                        } catch (err) {
                            document.execCommand('copy'); // Fallback
                        }
                    }
                }
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxCut').addEventListener('click', async () => {
                if (contextMenu.dataset.targetType === 'image') {
                    // Copy Image then Delete
                    const src = contextMenu.dataset.imageSrc;

                    try {
                        const response = await fetch(src);
                        const blob = await response.blob();
                        await navigator.clipboard.write([
                            new ClipboardItem({
                                [blob.type]: blob
                            })
                        ]);
                    } catch (err) {
                        console.error('Copy image failed during cut', err);
                    }

                    // Delete logic
                    const id = contextMenu.dataset.imageId;
                    if (id) {
                        deleteImage(parseFloat(id));
                    } else if (contextMenu.currentElement) {
                        contextMenu.currentElement.remove();
                    }
                } else {
                    document.execCommand('cut');
                }
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxDelete').addEventListener('click', () => {
                if (contextMenu.dataset.targetType === 'image') {
                    const id = contextMenu.dataset.imageId;
                    if (id) {
                        deleteImage(parseFloat(id));
                    } else if (contextMenu.currentElement) {
                        contextMenu.currentElement.remove();
                    }
                } else {
                    document.execCommand('delete');
                }
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxSaveAs').addEventListener('click', () => {
                const src = contextMenu.dataset.imageSrc;
                if (src) {
                    const a = document.createElement('a');
                    a.href = src;
                    a.download = 'download';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxSelectAll').addEventListener('click', () => {
                const targetType = contextMenu.dataset.targetType;
                if (targetType === 'input') {
                    const textInput = document.getElementById('textInput');
                    const range = document.createRange();
                    range.selectNodeContents(textInput);
                    const sel = window.getSelection();
                    sel.removeAllRanges();
                    sel.addRange(range);
                } else {
                    // Select right panel content (parsedText)
                    const content = document.getElementById('parsedText');
                    if (content && content.style.display !== 'none') {
                        const range = document.createRange();
                        range.selectNodeContents(content);
                        const sel = window.getSelection();
                        sel.removeAllRanges();
                        sel.addRange(range);
                    }
                }
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxPaste').addEventListener('click', async () => {
                handlePaste();
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxPastePlain').addEventListener('click', async () => {
                try {
                    const text = await navigator.clipboard.readText();
                    document.execCommand('insertText', false, text);
                } catch (err) {
                    showToast('无法访问剪贴板', 'error');
                }
                contextMenu.classList.remove('active');
            });

            document.getElementById('ctxAddImage').addEventListener('click', () => {
                document.getElementById('fileInput').click();
                contextMenu.classList.remove('active');
            });

            // Submenu actions
            contextMenu.querySelectorAll('[data-cmd]').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const cmd = item.dataset.cmd;
                    const val = item.dataset.val || null;
                    document.execCommand(cmd, false, val);
                    contextMenu.classList.remove('active');
                });
            });
        }

        // 渲染图片
        function renderImages() {
            const imagePreview = document.getElementById('imagePreview');

            // If we are dragging, we don't want to full re-render as it kills the drag state
            // But we need to update selection styles
            if (draggedItem) {
                const items = imagePreview.querySelectorAll('.image-preview-item');
                items.forEach(item => {
                    const id = parseFloat(item.dataset.id);
                    if (selectedImages.has(id)) item.classList.add('selected');
                    else item.classList.remove('selected');
                });
                return;
            }

            imagePreview.innerHTML = '';
            uploadedImages.forEach((image, index) => {
                const item = document.createElement('div');
                item.className = 'image-preview-item';
                if (selectedImages.has(image.id)) {
                    item.classList.add('selected');
                }
                item.draggable = true;
                item.dataset.id = image.id;
                item.dataset.index = index;

                item.innerHTML = `
                    <img src="${image.url}" alt="${image.name}">
                    <button class="image-delete-btn" data-id="${image.id}">
                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                `;

                // Click to select
                item.addEventListener('click', function (e) {
                    if (e.target.closest('.image-delete-btn')) return;

                    // Hide tooltip if active
                    hideTooltip();

                    // Stop propagation to prevent document click handler from clearing selection
                    e.stopPropagation();

                    if (e.ctrlKey || e.metaKey) {
                        if (selectedImages.has(image.id)) selectedImages.delete(image.id);
                        else selectedImages.add(image.id);
                        renderImages();
                    } else {
                        selectedImages.clear();
                        selectedImages.add(image.id);
                        renderImages();
                        showImageModal(image.url);
                    }
                });

                item.querySelector('.image-delete-btn').addEventListener('click', function (e) {
                    e.stopPropagation();
                    deleteImage(image.id);
                });

                // Drag events
                item.addEventListener('dragstart', function (e) {
                    draggedItem = image;
                    item.classList.add('dragging');
                    e.dataTransfer.effectAllowed = 'move';
                    e.dataTransfer.setData('text/plain', image.id);

                    // Select if not selected
                    if (!selectedImages.has(image.id)) {
                        selectedImages.clear();
                        selectedImages.add(image.id);
                        // Update styles manually to avoid re-render
                        document.querySelectorAll('.image-preview-item').forEach(el => el.classList.remove('selected'));
                        item.classList.add('selected');
                    }

                    // Create placeholder immediately
                    setTimeout(() => {
                        item.style.display = 'none';
                        createPlaceholder(index);
                    }, 0);
                });

                item.addEventListener('dragend', function () {
                    draggedItem = null;
                    item.classList.remove('dragging');
                    item.style.display = '';
                    removePlaceholder();
                    renderImages(); // Re-render to ensure clean state
                });

                imagePreview.appendChild(item);
            });
            updateEditorStats();
        }

        // Placeholder helpers
        function createPlaceholder(index) {
            const imagePreview = document.getElementById('imagePreview');
            let placeholder = document.getElementById('dragPlaceholder');
            if (!placeholder) {
                placeholder = document.createElement('div');
                placeholder.id = 'dragPlaceholder';
                placeholder.className = 'image-placeholder';
            }

            const items = Array.from(imagePreview.children).filter(el => el.style.display !== 'none');
            if (index < items.length) {
                imagePreview.insertBefore(placeholder, items[index]);
            } else {
                imagePreview.appendChild(placeholder);
            }
        }

        function removePlaceholder() {
            const placeholder = document.getElementById('dragPlaceholder');
            if (placeholder) placeholder.remove();
        }

        // 粘贴处理逻辑
        async function handlePaste() {
            // 降级处理：尝试使用 execCommand
            document.getElementById('textInput').focus();
            const success = document.execCommand('paste');
            if (success) return;

            // 如果 execCommand 失败，尝试使用 Clipboard API (仅支持文本和截图，不支持文件系统文件)
            if (!navigator.clipboard || !window.ClipboardItem) {
                showToast('当前浏览器不支持剪贴板API', 'error');
                return;
            }


            try {
                const items = await navigator.clipboard.read();
                let hasHandled = false;

                for (const item of items) {
                    // 1. 优先处理图片
                    const imageType = item.types.find(type => type.startsWith('image/') || type.includes('heic') || type.includes('heif'));
                    if (imageType) {
                        if (uploadedImages.length >= maxImages) {
                            showToast(`最多只能上传${maxImages}张图片`, 'warning');
                            return;
                        }

                        let blob = await item.getType(imageType);
                        let name = '剪贴板图片';

                        const isHEIC = imageType.includes('heic') || imageType.includes('heif');
                        if (isHEIC) {
                            try {
                                showToast('正在转换 HEIC 图片...', 'info');
                                await loadHeicScript();
                                const convertedBlob = await heic2any({
                                    blob: blob,
                                    toType: 'image/jpeg',
                                    quality: 0.7
                                });
                                blob = Array.isArray(convertedBlob) ? convertedBlob[0] : convertedBlob;
                                name = '剪贴板图片.jpg';
                            } catch (err) {
                                console.error('HEIC conversion failed', err);
                                showToast('HEIC 转换失败', 'error');
                                continue;
                            }
                        }

                        const reader = new FileReader();
                        reader.onload = function (e) {
                            const imageData = {
                                id: Date.now() + Math.random(),
                                url: e.target.result,
                                name: name
                            };
                            uploadedImages.push(imageData);
                            renderImages();
                            showToast('剪贴板图片已上传', 'success');
                        };
                        reader.readAsDataURL(blob);
                        hasHandled = true;
                        break;
                    }

                    // 2. 优先处理纯文本 (避免 HTML 格式破坏)
                    if (item.types.includes('text/plain')) {
                        const blob = await item.getType('text/plain');
                        const text = await blob.text();
                        document.execCommand('insertText', false, text);
                        hasHandled = true;
                        break;
                    }
                }

                if (!hasHandled) {
                    showToast('剪贴板中没有可粘贴的图片或文本', 'warning');
                }

            } catch (err) {
                console.error(err);
                // 降级处理：尝试直接读取文本
                try {
                    const text = await navigator.clipboard.readText();
                    if (text) {
                        document.execCommand('insertText', false, text);
                    } else {
                        showToast('无法访问剪贴板内容', 'error');
                    }
                } catch (e) {
                    showToast('无法访问剪贴板', 'error');
                }
            }
        }

        // 删除图片
        function deleteImage(id) {
            uploadedImages = uploadedImages.filter(img => img.id !== id);
            selectedImages.delete(id);
            renderImages();
            showToast('图片已删除', 'success');
        }

        // 图片上传
        function initImageUpload() {
            const leftPanel = document.getElementById('leftPanel');
            const fileInput = document.getElementById('fileInput');
            const imagePreview = document.getElementById('imagePreview');
            const imageBtn = document.getElementById('imageBtn');

            // Container Drag Events for Reordering
            imagePreview.addEventListener('dragover', function (e) {
                e.preventDefault();
                if (!draggedItem) return;

                const placeholder = document.getElementById('dragPlaceholder');
                if (!placeholder) return;

                // Get all items except placeholder and hidden dragged item
                const items = Array.from(imagePreview.children).filter(el =>
                    el !== placeholder && el.style.display !== 'none' && el.classList.contains('image-preview-item')
                );

                // Find the element under cursor
                const target = e.target.closest('.image-preview-item');

                if (target && target !== placeholder && target.style.display !== 'none') {
                    const box = target.getBoundingClientRect();
                    const next = (e.clientX - box.left) > (box.width / 2);

                    if (next) {
                        imagePreview.insertBefore(placeholder, target.nextSibling);
                    } else {
                        imagePreview.insertBefore(placeholder, target);
                    }
                } else if (items.length === 0) {
                    imagePreview.appendChild(placeholder);
                } else {
                    // If not over any item, check if we are at the end
                    const lastItem = items[items.length - 1];
                    const lastBox = lastItem.getBoundingClientRect();
                    if (e.clientY > lastBox.bottom || (e.clientY > lastBox.top && e.clientX > lastBox.right)) {
                        imagePreview.appendChild(placeholder);
                    }
                }
            });

            imagePreview.addEventListener('drop', function (e) {
                e.preventDefault();
                if (!draggedItem) return;

                const placeholder = document.getElementById('dragPlaceholder');
                if (placeholder) {
                    // Reconstruct uploadedImages based on DOM order
                    const newOrder = [];
                    const allChildren = Array.from(imagePreview.children);

                    allChildren.forEach(child => {
                        if (child === placeholder) {
                            newOrder.push(draggedItem);
                        } else if (child.classList.contains('image-preview-item') && child.style.display !== 'none') {
                            const id = parseFloat(child.dataset.id);
                            const img = uploadedImages.find(i => i.id === id);
                            if (img) newOrder.push(img);
                        }
                    });

                    uploadedImages = newOrder;
                }
                // dragend will handle cleanup
            });

            // 图片按钮点击
            imageBtn.addEventListener('click', function () {
                if (uploadedImages.length >= maxImages) {
                    showToast(`最多只能上传${maxImages}张图片`, 'warning');
                    return;
                }
                fileInput.click();
            });

            // 文件选择
            fileInput.addEventListener('change', function (e) {
                handleFiles(e.target.files);
            });

            // 拖拽上传 - 绑定到左侧面板
            const dragOverlay = document.getElementById('dragOverlay');
            leftPanel.addEventListener('dragover', function (e) {
                // 如果正在内容区域拖拽纯文本，允许浏览器默认行为（以便文字能落入编辑框）
                const isContentArea = !!e.target.closest('.content-area');
                const hasFiles = e.dataTransfer.types && e.dataTransfer.types.includes('Files');
                const hasUriList = e.dataTransfer.types && e.dataTransfer.types.includes('text/uri-list');

                if (isContentArea && !hasFiles && !hasUriList) {
                    dragOverlay.classList.remove('active');
                    return;
                }

                e.preventDefault();
                // If dragging an internal item, don't show overlay
                if (draggedItem) return;

                // 检查是否为文件或图片链接
                let isFile = false;
                let isImage = false;

                if (e.dataTransfer.types) {
                    const types = Array.from(e.dataTransfer.types);
                    if (types.includes('Files')) isFile = true;
                    if (types.includes('text/uri-list')) isImage = true;
                }

                // 进一步检查文件类型
                let hasNonImageFile = false;
                if (e.dataTransfer.items) {
                    for (let i = 0; i < e.dataTransfer.items.length; i++) {
                        const item = e.dataTransfer.items[i];
                        const t = item.type || '';
                        if (t.startsWith('image/')) {
                            isImage = true;
                        } else if (item.kind === 'file' && t) {
                            hasNonImageFile = true;
                        }
                    }
                }

                // 如果既不是文件也不是图片链接（例如纯文本），则不显示遮罩
                if (!isFile && !isImage) {
                    dragOverlay.classList.remove('active');
                    return;
                }

                dragOverlay.classList.add('active');
                dragOverlay.classList.remove('error', 'success', 'full');

                if (!isImage && hasNonImageFile) {
                    dragOverlay.classList.add('error');
                    dragOverlay.textContent = '不支持的内容';
                } else if (uploadedImages.length >= maxImages) {
                    dragOverlay.classList.add('full');
                    dragOverlay.textContent = '最多只能上传4张图片';
                } else if (isImage || isFile) {
                    dragOverlay.classList.add('success');
                    dragOverlay.textContent = '拖入图片以添加';
                } else {
                    dragOverlay.classList.add('error');
                    dragOverlay.textContent = '不支持的内容';
                }
            });
            leftPanel.addEventListener('dragleave', function (e) {
                e.preventDefault();
                dragOverlay.classList.remove('active', 'error', 'success', 'full');
                dragOverlay.textContent = '拖入图片以添加';
            });
            leftPanel.addEventListener('drop', function (e) {
                // 如果目标在内容区域且拖拽的不是文件或图片链接（即普通文本），允许默认行为
                const isContentArea = !!e.target.closest('.content-area');
                const hasFiles = e.dataTransfer.types && e.dataTransfer.types.includes('Files');
                const hasUriList = e.dataTransfer.types && e.dataTransfer.types.includes('text/uri-list');

                if (isContentArea && !hasFiles && !hasUriList) {
                    dragOverlay.classList.remove('active', 'error', 'success', 'full');
                    return;
                }

                e.preventDefault();
                // If dragging internal item, handle reorder
                if (draggedItem) {
                    return;
                }

                dragOverlay.classList.remove('active', 'error', 'success', 'full');

                // 优先处理文件
                if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                    const hasImage = Array.from(e.dataTransfer.files).some(f => {
                        const isHEIC = f.name.toLowerCase().endsWith('.heic') || f.name.toLowerCase().endsWith('.heif');
                        return f.type.startsWith('image/') || isHEIC;
                    });
                    if (!hasImage) {
                        showToast('不支持的内容', 'error');
                        return;
                    }

                    if (uploadedImages.length >= maxImages) {
                        showToast(`最多只能上传${maxImages}张图片`, 'warning');
                        return;
                    }
                    handleFiles(e.dataTransfer.files);
                    return;
                }

                // 处理 URL
                let url = '';
                try {
                    if (e.dataTransfer) {
                        // 优先使用 uri-list
                        url = e.dataTransfer.getData('text/uri-list');

                        // 如果没有 uri-list，检查 text/plain 是否像 URL
                        if (!url) {
                            const text = e.dataTransfer.getData('text/plain');
                            // 简单的 URL 校验，避免普通文本被误认
                            if (text && (text.startsWith('http://') || text.startsWith('https://') || text.startsWith('data:image'))) {
                                url = text;
                            }
                        }
                    }
                } catch (err) {
                    url = '';
                }

                if (url) {
                    if (uploadedImages.length >= maxImages) {
                        showToast(`最多只能上传${maxImages}张图片`, 'warning');
                        return;
                    }
                    // 简单判断是否为图片链接
                    const lower = url.toLowerCase();
                    const isLikelyImage = lower.startsWith('data:') || /(\.png|\.jpe?g|\.gif|\.webp|\.bmp|\.svg)(\?.*)?$/.test(lower) || /^https?:\/\/.+\.(png|jpe?g|gif|webp|bmp|svg)(\?.*)?$/i.test(url);

                    const imagePreview = document.getElementById('imagePreview');
                    const nameFromUrl = url.split('/').pop().split('?')[0];
                    const imageData = {
                        id: Date.now() + Math.random(),
                        url: url,
                        name: nameFromUrl || '远程图片'
                    };
                    // 如果不是显然为图片，也允许加入（浏览器会根据 src 显示或失败）
                    uploadedImages.push(imageData);
                    // 使用已有渲染函数更新 UI
                    renderImages();
                    showToast('图片已从右侧添加', 'success');
                    return;
                }

                showToast('无可用图片或不支持的拖放内容', 'error');
            });

            // 粘贴上传
            document.addEventListener('paste', function (e) {
                let hasHandled = false;

                // 1. 优先检查 files 列表（支持从文件管理器复制的文件）
                if (e.clipboardData.files && e.clipboardData.files.length > 0) {
                    const imageFiles = Array.from(e.clipboardData.files).filter(file => {
                        const isHEIC = file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');
                        return file.type.startsWith('image/') || isHEIC;
                    });
                    if (imageFiles.length > 0) {
                        e.preventDefault();
                        handleFiles(imageFiles);
                        hasHandled = true;
                    }
                }

                // 2. 检查 items（支持截图等）
                if (!hasHandled) {
                    const items = e.clipboardData.items;
                    for (let item of items) {
                        if (item.type.indexOf('image') !== -1 || item.type.indexOf('heic') !== -1 || item.type.indexOf('heif') !== -1) {
                            e.preventDefault();
                            const file = item.getAsFile();
                            if (file) {
                                handleFiles([file]);
                                hasHandled = true;
                            }
                            break;
                        }
                    }
                }

                // 3. 如果焦点不在输入框，尝试处理纯文本
                if (!hasHandled && document.activeElement !== document.getElementById('textInput')) {
                    const text = e.clipboardData.getData('text/plain');
                    if (text) {
                        e.preventDefault();
                        const textInput = document.getElementById('textInput');
                        textInput.focus();
                        document.execCommand('insertText', false, text);
                        hasHandled = true;
                    }
                }

                if (!hasHandled) {
                    showToast('剪贴板中没有可粘贴的图片或文本', 'warning');
                }
            });

            // 处理文件
            async function handleFiles(files) {
                const remain = maxImages - uploadedImages.length;
                if (remain <= 0) {
                    showToast(`最多只能上传${maxImages}张图片`, 'warning');
                    return;
                }

                let addedCount = 0;
                const fileList = Array.from(files);

                for (const file of fileList) {
                    if (addedCount >= remain) break;

                    const isHEIC = file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');
                    if (!file.type.startsWith('image/') && !isHEIC) {
                        continue;
                    }

                    let processFile = file;
                    if (isHEIC) {
                        try {
                            showToast('正在转换 HEIC 图片...', 'info');
                            await loadHeicScript();
                            const blob = await heic2any({
                                blob: file,
                                toType: 'image/jpeg',
                                quality: 0.7
                            });
                            const finalBlob = Array.isArray(blob) ? blob[0] : blob;
                            processFile = new File([finalBlob], file.name.replace(/\.(heic|heif)$/i, '.jpg'), { type: 'image/jpeg' });
                        } catch (err) {
                            console.error('HEIC conversion failed', err);
                            showToast('HEIC 转换失败', 'error');
                            continue;
                        }
                    }

                    await new Promise((resolve) => {
                        const reader = new FileReader();
                        reader.onload = function (e) {
                            const imageData = {
                                id: Date.now() + Math.random(),
                                url: e.target.result,
                                name: processFile.name
                            };
                            uploadedImages.push(imageData);
                            renderImages();
                            addedCount++;
                            resolve();
                        };
                        reader.readAsDataURL(processFile);
                    });
                }

                if (addedCount > 0) {
                    showToast(`成功添加 ${addedCount} 张图片`, 'success');
                } else if (files.length > 0) {
                    showToast('不支持的内容或添加失败', 'error');
                }
            }

            // Context Menu
            imagePreview.addEventListener('contextmenu', function (e) {
                e.preventDefault();
                const item = e.target.closest('.image-preview-item');
                if (item) {
                    const id = parseFloat(item.dataset.id);
                    // If right clicking an item not in selection, select it (and deselect others)
                    if (!selectedImages.has(id)) {
                        selectedImages.clear();
                        selectedImages.add(id);
                        renderImages();
                    }
                }
            });

            // Right side images context menu
            const parsedImages = document.getElementById('parsedImages');
            if (parsedImages) {
                parsedImages.addEventListener('contextmenu', function (e) {
                    const item = e.target.closest('.parsed-image-item');
                    if (item) {
                        e.preventDefault();
                    }
                });
            }

        }

        // 自定义弹窗逻辑
        function showCustomModal(options) {
            if (typeof options === 'function') {
                options = {
                    onConfirm: options,
                    onCancel: arguments[1],
                    title: '确认操作',
                    message: '确定要清空所有内容吗？',
                    confirmText: '确定',
                    cancelText: '取消'
                };
            }

            const modal = document.getElementById('customModal');
            const titleEl = modal.querySelector('.custom-modal-title');
            const messageEl = modal.querySelector('.custom-modal-message');
            const confirmBtn = document.getElementById('modalConfirm');
            const cancelBtn = document.getElementById('modalCancel');

            // 查找或创建第三个按钮
            let optionBtn = document.getElementById('modalOption');
            if (!optionBtn) {
                optionBtn = document.createElement('button');
                optionBtn.id = 'modalOption';
                optionBtn.className = 'custom-modal-btn';
                optionBtn.style.display = 'none';
                confirmBtn.parentNode.insertBefore(optionBtn, confirmBtn);
            }

            titleEl.textContent = options.title || '确认操作';
            messageEl.textContent = options.message || '确定要清空所有内容吗？';
            confirmBtn.textContent = options.confirmText || '确定';
            cancelBtn.textContent = options.cancelText || '取消';

            // 恢复按钮默认类名
            confirmBtn.className = 'custom-modal-btn';
            cancelBtn.className = 'custom-modal-btn';
            optionBtn.className = 'custom-modal-btn';

            if (options.optionText) {
                optionBtn.textContent = options.optionText;
                optionBtn.style.display = 'inline-block';
                optionBtn.onclick = function () {
                    modal.classList.remove('active');
                    if (options.onOption) options.onOption();
                };
            } else {
                optionBtn.style.display = 'none';
            }

            modal.classList.add('active');

            // 解绑旧事件
            confirmBtn.onclick = function () {
                modal.classList.remove('active');
                if (options.onConfirm) options.onConfirm();
            };
            cancelBtn.onclick = function () {
                modal.classList.remove('active');
                if (options.onCancel) options.onCancel();
            };
        }

        // 按钮功能
        function initButtons() {
            document.querySelectorAll('.toolbar-btn:not(.more-menu), .detect-btn, .custom-modal-btn').forEach(btn => {
                btn.addEventListener('click', function (e) {
                    const ripple = document.createElement('span');
                    ripple.classList.add('ripple');
                    this.appendChild(ripple);

                    const rect = this.getBoundingClientRect();
                    const size = Math.max(rect.width, rect.height);

                    ripple.style.width = ripple.style.height = `${size}px`;
                    ripple.style.left = `${e.clientX - rect.left - size / 2}px`;
                    ripple.style.top = `${e.clientY - rect.top - size / 2}px`;

                    ripple.addEventListener('animationend', () => {
                        ripple.remove();
                    });
                });
            });

            // 页面预览功能
            document.getElementById('previewBtn').addEventListener('click', function () {
                const btn = this;
                const text = document.getElementById('textInput').innerHTML; // Use innerHTML to preserve formatting

                if (!document.getElementById('textInput').innerText.trim() && uploadedImages.length === 0) {
                    showToast('没有可预览的内容', 'warning');
                    return;
                }

                // Disable button to prevent multiple clicks
                btn.disabled = true;
                btn.style.opacity = '0.5';
                btn.style.pointerEvents = 'none';

                if (isURL(document.getElementById('textInput').innerText.trim())) {
                    // URL Preview
                    extractContent(document.getElementById('textInput').innerText.trim(), true);
                } else {
                    // Local Preview
                    renderPreview(text, uploadedImages);
                    showToast('已生成本地预览', 'success');

                    // Re-enable after a short delay for local preview
                    setTimeout(() => {
                        btn.disabled = false;
                        btn.style.opacity = '1';
                        btn.style.pointerEvents = 'auto';
                    }, 500);
                }
            });

            // 导入文件按钮
            const importFileBtn = document.getElementById('importFileBtn');
            if (importFileBtn) {
                // Remove existing listeners by cloning node (cleanest way for anonymous listener)
                const newBtn = importFileBtn.cloneNode(true);
                importFileBtn.parentNode.replaceChild(newBtn, importFileBtn);

                // Create hidden file input
                const fileInput = document.createElement('input');
                fileInput.type = 'file';
                fileInput.accept = '.txt,.md,.doc,.docx,.pdf,.xlsx,.xls';
                fileInput.style.display = 'none';
                document.body.appendChild(fileInput);

                newBtn.addEventListener('click', () => {
                    fileInput.click();
                });

                fileInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    // Size Check (Max 20MB)
                    const MAX_SIZE = 20 * 1024 * 1024;
                    if (file.size > MAX_SIZE) {
                        showToast(`文件大小超过20MB限制`, 'error');
                        fileInput.value = ''; // Reset
                        return;
                    }

                    // Cleanup previous content if not batch mode to satisfy "one file at a time"
                    if (!isBatchMode) {
                        clearEditorContent(false);
                    }

                    let ext = file.name.split('.').pop().toLowerCase();
                    let finalFile = file;

                    // Support HEIC/HEIF conversion
                    if (ext === 'heic' || ext === 'heif') {
                        try {
                            showToast('正在转换 HEIC 图片...', 'info');
                            await loadHeicScript();
                            const convertedBlob = await heic2any({
                                blob: file,
                                toType: 'image/jpeg',
                                quality: 0.8
                            });
                            const finalBlob = Array.isArray(convertedBlob) ? convertedBlob[0] : convertedBlob;
                            finalFile = new File([finalBlob], file.name.replace(/\.(heic|heif)$/i, '.jpg'), { type: 'image/jpeg' });
                            ext = 'jpg';
                        } catch (err) {
                            console.error('HEIC conversion failed:', err);
                            showToast('HEIC 转换失败，尝试直接上传', 'warning');
                        }
                    }

                    const reader = new FileReader();

                    // Process function
                    const processFile = async (dataBase64) => {
                        try {
                            showToast('正在解析文件...', 'info');
                            const res = await api.invoke('process-file-upload', {
                                name: file.name,
                                data: dataBase64.split(',')[1] // remove data prefix
                            });

                            const fileResult = res; // api.invoke returns res.data directly if success is true

                            const sanitizeImportedImages = (imgs) => {
                                if (!Array.isArray(imgs)) return [];
                                return imgs.filter(img => {
                                    if (typeof img !== 'string') return false;
                                    const trimmed = img.trim();
                                    if (trimmed.startsWith('data:image/')) return true;
                                    return /^(http|https|file):\/\//i.test(trimmed);
                                });
                            };

                            if (ext === 'xlsx' || ext === 'xls') {
                                // Excel Logic
                                showCustomModal({
                                    title: '导入Excel文件',
                                    message: '检测到Excel文件，是否进入批量模式进行处理？',
                                    confirmText: '进入批量模式',
                                    cancelText: '仅导入内容',
                                    onConfirm: async () => {
                                        if (!isBatchMode) enterBatchMode();
                                        if (fileResult.type === 'excel' && Array.isArray(fileResult.data)) {
                                            fileResult.data.forEach(item => {
                                                // item: { content: "...", images: [] }
                                                // If parser returns string content, parse it back?
                                                // Backend returns: { content: JSON string, ... }
                                                try {
                                                    const rowObj = JSON.parse(item.content);
                                                    // Convert row object to nice string
                                                    const txt = Object.values(rowObj).join('\n');
                                                    addBatchItem(txt, []);
                                                } catch {
                                                    addBatchItem(item.content, []);
                                                }
                                            });
                                            renderBatchList();
                                            showToast(`已导入 ${fileResult.data.length} 条数据`, 'success');
                                        }
                                    },
                                    onCancel: () => {
                                        showToast('Excel文件导入仅支持批量模式', 'info');
                                    }
                                });
                            } else {
                                // Text/PDF/Docx Logic
                                const { text = '', images = [] } = fileResult.data || {};
                                const validImages = sanitizeImportedImages(images);

                                const applyToEditor = () => {
                                    const textInput = document.getElementById('textInput');
                                    if (textInput) {
                                        textInput.innerText = text || '';
                                        textInput.dispatchEvent(new Event('input'));
                                        updateEditorStats();
                                    }

                                    // Process images
                                    if (validImages.length > 0) {
                                        validImages.forEach(imgStr => {
                                            if (uploadedImages.length < maxImages) {
                                                uploadedImages.push({
                                                    id: Date.now() + Math.random(),
                                                    url: imgStr,
                                                    name: 'Imported Image'
                                                });
                                            }
                                        });
                                        renderImages();
                                    }

                                    // Update UI states safely
                                    if (typeof updateBtnState === 'function') updateBtnState();
                                    if (typeof updateClearButtonState === 'function') updateClearButtonState();
                                    if (typeof updateEditorStats === 'function') updateEditorStats();
                                };

                                if (isBatchMode) {
                                    if (isBatchEditMode && currentBatchEditId) {
                                        const item = batchItems.find(i => i.id === currentBatchEditId);
                                        if (item) {
                                            item.content = text;
                                            renderBatchList();
                                            // Editor is synced elsewhere?
                                            applyToEditor();
                                        }
                                    } else {
                                        addBatchItem(text, validImages);
                                        renderBatchList();
                                        showToast('已添加到批量列表', 'success');
                                    }
                                } else {
                                    applyToEditor();
                                    showToast('文件导入成功', 'success');
                                }

                            }

                        } catch (err) {
                            console.error(err);
                            showError('文件处理失败: ' + err.message);
                        }
                        // Reset input
                        fileInput.value = '';
                    };

                    reader.onload = function (evt) {
                        processFile(evt.target.result);
                    };
                    reader.readAsDataURL(finalFile);
                });
            }


            // 清空按钮
            document.getElementById('clearBtn').addEventListener('click', function () {
                showCustomModal(() => {
                    clearEditorContent();
                });
            });

            // 检测按钮
            let lastTextContent = '';
            let lastImages = [];
            document.getElementById('detectBtn').addEventListener('click', function () {
                // Batch Mode Interception
                if (typeof isBatchMode !== 'undefined' && isBatchMode) {
                    startBatchDetection();
                    return;
                }

                const textContent = document.getElementById('textInput').innerText.trim();
                const count = textContent.replace(/\s+/g, '').length;

                if (count > 10000) {
                    showToast('字数超过最大限制 (10000字)，请缩减内容后再试', 'error');
                    return;
                }

                const htmlContent = document.getElementById('textInput').innerHTML; // Get HTML content
                // 优先判断内容是否为空
                if (!textContent) {
                    if (uploadedImages.length > 0) {
                        showToast('请添加相关的文本内容以进行检测', 'warning');
                    } else {
                        showToast('请输入需要检测的新闻内容', 'warning');
                    }
                    return;
                }
                // 判断内容和图片是否有变化
                const imagesNow = uploadedImages.map(img => img.url).join(',');
                const imagesLast = lastImages.join(',');
                // 检查右侧是否为空（初始状态是否显示）
                const isResultEmpty = document.getElementById('initialState').style.display !== 'none';
                // 检查是否处于错误状态
                const isErrorState = document.getElementById('errorState').classList.contains('active');

                // 检查是否处于预览模式（评分区域被隐藏）
                const scoreSection = document.querySelector('.result-score');
                const isPreviewMode = scoreSection && scoreSection.style.display === 'none';

                if (textContent === lastTextContent && imagesNow === imagesLast && !isResultEmpty && !isErrorState && !isPreviewMode) {
                    showToast('内容未变化，无需重复检测', 'info');
                    return;
                }

                // 提取所有URL
                const foundUrls = extractURLs(textContent);

                // 如果发现多个URL
                if (foundUrls.length > 1) {
                    showCustomModal({
                        title: '检测到多个链接',
                        message: `检测到输入内容包含 ${foundUrls.length} 个链接，是否进入批量模式分别检测？`,
                        confirmText: '进入批量模式',
                        optionText: '仅作为文本检测',
                        cancelText: '取消',
                        onConfirm: () => {
                            const textInput = document.getElementById('textInput');
                            if (textInput) textInput.innerHTML = '';
                            uploadedImages = [];
                            renderImages();
                            updateEditorStats();

                            if (!isBatchMode) enterBatchMode();

                            let addedCount = 0;
                            for (const url of foundUrls) {
                                if (addBatchItem(url, [])) {
                                    addedCount++;
                                } else {
                                    break; // Stop if limit reached
                                }
                            }
                            renderBatchList();
                            if (addedCount > 0) {
                                showToast(`已添加 ${addedCount} 个链接到批量列表`, 'success');
                            }
                        },
                        onOption: () => {
                            analyzeContent(textContent, uploadedImages, false, htmlContent);
                        },
                        onCancel: () => {
                            // 取消时关闭弹窗，无需额外操作
                        }
                    });
                    return;
                }

                // 检查是否为单个URL
                if (isURL(textContent)) {
                    if (uploadedImages.length > 0) {
                        // 弹出询问对话框
                        showCustomModal({
                            title: '检测到链接和图片',
                            message: '您输入了链接同时也上传了图片，请选择处理方式：',
                            confirmText: '仅提取链接内容', // 对应 extractContent
                            optionText: '图文混合分析', // 对应 analyzeContent
                            cancelText: '取消',
                            onConfirm: () => {
                                window.lastExtractedUrl = textContent;
                                extractContent(textContent);
                            },
                            onOption: () => {
                                window.lastExtractedUrl = null;
                                analyzeContent(textContent, uploadedImages, false, htmlContent);
                            },
                            onCancel: () => {
                                // 取消，不做任何事
                            }
                        });
                        return;
                    }

                    window.lastExtractedUrl = textContent;
                    extractContent(textContent);
                } else {
                    window.lastExtractedUrl = null;
                    analyzeContent(textContent, uploadedImages, false, htmlContent);
                }
                // 记录本次内容和图片
                lastTextContent = textContent;
                lastImages = uploadedImages.map(img => img.url);
            });
        }

        // 提取文本中的所有URL
        function extractURLs(text) {
            const urlRegex = /(https?:\/\/[^\s]+)/g;
            const matches = text.match(urlRegex) || [];
            return matches.filter(url => {
                try { new URL(url); return true; } catch { return false; }
            });
        }

        // 检查是否为URL
        function isURL(text) {
            try {
                new URL(text);
                return true;
            } catch {
                return false;
            }
        }

        // Helper to wrap image URLs with our proxy
        function getProxyUrl(url) {
            if (url && url.startsWith('http') && !url.includes(window.location.origin)) {
                // Only proxy if not already local
                return `/api/proxy-image?url=${encodeURIComponent(url)}`;
            }
            return url;
        }

        // 内容提取功能
        function extractContent(url, isPreview = false) {
            const detectBtn = document.getElementById('detectBtn');
            const previewBtn = document.getElementById('previewBtn');
            const initialState = document.getElementById('initialState');
            const resultItem = document.getElementById('resultItem');
            const loadingState = document.getElementById('loadingState');
            const errorState = document.getElementById('errorState');
            const progressBar = document.getElementById('progressBar');
            const loadingText = document.getElementById('loadingText');
            const cancelBtn = document.getElementById('cancelExtractBtn');

            // 禁用按钮防止重复点击
            if (detectBtn) {
                detectBtn.disabled = true;
                detectBtn.style.opacity = '0.5';
                detectBtn.style.pointerEvents = 'none';
            }
            if (previewBtn) {
                previewBtn.disabled = true;
                previewBtn.style.opacity = '0.5';
                previewBtn.style.pointerEvents = 'none';
            }

            // 重置状态
            initialState.style.display = 'none';
            resultItem.classList.remove('active');
            resultItem.style.display = 'none'; // Ensure hidden during loading
            errorState.classList.remove('active');
            loadingState.classList.add('active');

            // 显示取消按钮
            if (cancelBtn) cancelBtn.style.display = 'block';

            // 初始化进度条
            progressBar.style.width = '0%';
            loadingText.textContent = isPreview ? '正在解析网页以预览...' : '正在解析网页内容...';

            detectBtn.classList.add('loading');
            detectBtn.innerHTML = isPreview ? '预览中...' : '提取中...';

            // 模拟进度增长
            let progress = 10;
            const progressInterval = setInterval(() => {
                if (progress < 45) {
                    progress += 1;
                    progressBar.style.width = progress + '%';
                }
            }, 200);

            let timeoutId;
            let finished = false;

            // 取消处理逻辑
            function handleCancel() {
                if (finished) return;
                finished = true;
                clearTimeout(timeoutId);
                clearInterval(progressInterval);

                loadingState.classList.remove('active');
                detectBtn.classList.remove('loading');
                detectBtn.innerHTML = '开始检测';
                if (cancelBtn) cancelBtn.style.display = 'none';

                // Re-enable buttons
                if (detectBtn) {
                    detectBtn.disabled = false;
                    detectBtn.style.opacity = '1';
                    detectBtn.style.pointerEvents = 'auto';
                }
                if (previewBtn) {
                    previewBtn.disabled = false;
                    previewBtn.style.opacity = '1';
                    previewBtn.style.pointerEvents = 'auto';
                }

                // 恢复初始状态
                initialState.style.display = 'flex';

                showToast('用户已取消', 'info');
            }

            // 绑定取消按钮事件
            if (cancelBtn) {
                cancelBtn.onclick = function () {
                    if (finished) return;
                    api.send('cancel-extraction');
                    handleCancel();
                };
            }

            // 超时处理函数
            function handleTimeout() {
                if (finished) return;
                finished = true;
                clearInterval(progressInterval);
                loadingState.classList.remove('active');
                detectBtn.classList.remove('loading');
                detectBtn.innerHTML = '开始检测';
                if (cancelBtn) cancelBtn.style.display = 'none';

                // Re-enable buttons
                if (detectBtn) {
                    detectBtn.disabled = false;
                    detectBtn.style.opacity = '1';
                    detectBtn.style.pointerEvents = 'auto';
                }
                if (previewBtn) {
                    previewBtn.disabled = false;
                    previewBtn.style.opacity = '1';
                    previewBtn.style.pointerEvents = 'auto';
                }

                showError('网页内容提取超时，请稍后重试');
                showToast('提取失败：超时', 'error');
            }
            // 增加超时时间到 30 秒，以匹配后端爬虫的正常运行时间 (Playwright + 动态等待)
            timeoutId = setTimeout(handleTimeout, 30000);

            // 调用服务器的内容提取功能
            (async () => {
                try {
                    const result = await api.invoke('extract-content-sync', url);

                    if (finished) return;
                    finished = true;
                    clearTimeout(timeoutId);
                    clearInterval(progressInterval);
                    if (cancelBtn) cancelBtn.style.display = 'none';

                    // Re-enable buttons
                    if (detectBtn) {
                        detectBtn.disabled = false;
                        detectBtn.style.opacity = '1';
                        detectBtn.style.pointerEvents = 'auto';
                    }
                    if (previewBtn) {
                        previewBtn.disabled = false;
                        previewBtn.style.opacity = '1';
                        previewBtn.style.pointerEvents = 'auto';
                    }

                    if (result) {
                        // Skip proxying to save server bandwidth
                        /*
                        if (result.images) {
                            result.images = result.images.map(img => {
                                 if(typeof img === 'string') return getProxyUrl(img);
                                 if(img.url) img.url = getProxyUrl(img.url);
                                 return img;
                            });
                        }
                        // Proxy images in content HTML
                        if (result.content) {
                             result.content = result.content.replace(/<img[^>]+src="([^">]+)"/g, (match, src) => {
                                  if (src.startsWith('http') && !src.includes(window.location.origin)) {
                                      return match.replace(src, getProxyUrl(src));
                                  }
                                  return match;
                             });
                        }
                        */

                        if (isPreview) {
                            progressBar.style.width = '100%';
                            loadingState.classList.remove('active');
                            detectBtn.classList.remove('loading');
                            detectBtn.innerHTML = '开始检测';
                            renderPreview(result.content, result.images, result.title);
                            showToast('网页预览已生成', 'success');
                        } else {
                            // 提取成功，进度设为40%
                            progressBar.style.width = '40%';
                            loadingText.textContent = '正在分析新闻中...';

                            showToast('提取完成，正在进行新闻分析...', 'success');
                            // 传递 true 表示从提取流程进入
                            analyzeContent(result.textContent || result.content, result.images, true);
                        }
                    } else {
                        throw new Error('无法获取提取数据');
                    }
                } catch (err) {
                    if (finished) return;
                    finished = true;
                    clearTimeout(timeoutId);
                    clearInterval(progressInterval);

                    const errorMsg = err.message || '提取过程出错';
                    if (errorMsg === '提取已取消' || errorMsg.includes('canceled')) return;

                    showError(errorMsg);
                    showToast('提取失败: ' + errorMsg, 'error');

                    // Re-enable buttons on error
                    if (detectBtn) {
                        detectBtn.disabled = false;
                        detectBtn.classList.remove('loading');
                        detectBtn.innerHTML = '开始检测';
                        detectBtn.style.opacity = '1';
                        detectBtn.style.pointerEvents = 'auto';
                    }
                    if (previewBtn) {
                        previewBtn.disabled = false;
                        previewBtn.style.opacity = '1';
                        previewBtn.style.pointerEvents = 'auto';
                    }
                }
            })();
        }

        // 渲染预览内容（隐藏评分和观点）
        function renderPreview(text, images, title = null) {
            const initialState = document.getElementById('initialState');
            const resultItem = document.getElementById('resultItem');
            const parsedContent = document.getElementById('parsedContent');
            const parsedTitle = document.getElementById('parsedTitle');
            const parsedText = document.getElementById('parsedText');
            const parsedImages = document.getElementById('parsedImages');

            // Hide Score and Analysis
            const scoreSection = resultItem.querySelector('.result-score');
            const analysisSection = resultItem.querySelector('.result-analysis');
            if (scoreSection) scoreSection.style.display = 'none';
            if (analysisSection) analysisSection.style.display = 'none';

            // Show Content
            parsedContent.style.display = 'block';

            parsedTitle.textContent = title || '';
            parsedTitle.style.display = title ? 'block' : 'none';
            parsedText.innerHTML = text || ''; // Use innerHTML
            parsedText.classList.add('is-html'); // Add class for HTML content
            // 预览模式下也需要将内嵌图片转换为 base64，防止防盗链导致破图
            convertImagesToBase64(parsedText);
            bindImagePreview(parsedText);

            // Render Images
            parsedImages.innerHTML = '';
            let imagesToRender = [];
            if (images && images.length > 0) {
                const limitedImages = images.slice(0, 4);
                imagesToRender = limitedImages.map(img => {
                    if (typeof img === 'string') return { url: img, name: 'Image' };
                    if (img && typeof img === 'object' && img.url) return img;
                    return { url: '', name: 'Invalid Image' };
                }).filter(img => img.url);
            }

            if (imagesToRender.length > 0) {
                const container = document.createElement('div');
                container.className = 'parsed-images';

                imagesToRender.forEach(img => {
                    const item = document.createElement('div');
                    item.className = 'parsed-image-item';
                    let displaySrc = img.url;
                    // 统一通过后端代理处理远程图片，避免预览时破图
                    if (displaySrc && !displaySrc.startsWith('data:') && !displaySrc.startsWith('blob:')) {
                        displaySrc = `/api/proxy-image?url=${encodeURIComponent(displaySrc)}`;
                    }

                    item.innerHTML = `<img src="${displaySrc}" data-original-src="${img.url}" alt="${img.name}" onerror="this.onerror=null; this.src='/ico/Detect.ico'; this.style.opacity='0.4';">`;
                    item.addEventListener('click', () => showImageModal(displaySrc));
                    container.appendChild(item);
                });
                // 生成后异步再转 base64，确保预览顶部图片不破碎
                convertImagesToBase64(container);
                bindImagePreview(container);
                parsedImages.appendChild(container);
            }

            initialState.style.display = 'none';
            const loadingState = document.getElementById('loadingState');
            const errorState = document.getElementById('errorState');
            if (loadingState) loadingState.classList.remove('active');
            if (errorState) errorState.classList.remove('active');

            resultItem.classList.add('active');
            resultItem.style.display = 'block'; // Ensure visible
        }

        // 初始化导出功能
        function initExport() {
            // Dropdown items logic
            document.querySelectorAll('#exportDropdown .dropdown-item').forEach(item => {
                item.addEventListener('click', () => {
                    const format = item.getAttribute('data-format');
                    exportResult(format);
                    const dropdown = document.getElementById('exportDropdown');
                    if (dropdown) dropdown.classList.remove('show');
                });
            });

            // Context Menu
            const rightPanel = document.getElementById('rightPanel');
            const resultContextMenu = document.getElementById('resultContextMenu');
            const ctxExportResult = document.getElementById('ctxExportResult');
            const ctxResultCopy = document.getElementById('ctxResultCopy');
            const ctxResultSelectAll = document.getElementById('ctxResultSelectAll');
            const ctxResultSearch = document.getElementById('ctxResultSearch');
            const ctxResultGoTo = document.getElementById('ctxResultGoTo');
            const ctxResultSearchSep = document.getElementById('ctxResultSearchSep');

            if (rightPanel && resultContextMenu) {
                // Use capture phase to intercept event before it bubbles up or is handled by others
                rightPanel.addEventListener('contextmenu', function (e) {
                    const resultItem = document.getElementById('resultItem');
                    const isResultActive = resultItem && resultItem.classList.contains('active');
                    const isFullscreen = document.body.classList.contains('detection-fullscreen');

                    // Show menu if result is active OR if in fullscreen mode (even if showing initial state)
                    if (isResultActive || isFullscreen) {
                        // 如果是图片，不拦截，让全局右键菜单处理（显示图片相关菜单）
                        if (e.target.tagName === 'IMG') {
                            return;
                        }

                        e.preventDefault();
                        e.stopPropagation(); // Stop propagation

                        // Position menu
                        let x = e.clientX;
                        let y = e.clientY;

                        // Measure height
                        resultContextMenu.style.visibility = 'hidden';
                        resultContextMenu.classList.add('active');
                        const menuWidth = resultContextMenu.offsetWidth;
                        const menuHeight = resultContextMenu.offsetHeight;
                        resultContextMenu.classList.remove('active');
                        resultContextMenu.style.visibility = 'visible';

                        const winWidth = window.innerWidth;
                        const winHeight = window.innerHeight;

                        // Adjust X
                        if (x + menuWidth > winWidth) {
                            x = winWidth - menuWidth - 5;
                        }

                        // Adjust Y
                        if (y + menuHeight > winHeight) {
                            y = winHeight - menuHeight - 5;
                        }

                        // Avoid overlapping with custom title bar
                        if (y < 35) y = 35;

                        // Check for selection to toggle Copy/Search/GoTo options
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();
                        const hasSelection = selectedText.length > 0;
                        const isUrl = selectedText && /^(http|https):\/\/[^ "]+$/.test(selectedText);

                        if (ctxResultCopy) {
                            ctxResultCopy.style.display = hasSelection ? 'flex' : 'none';
                        }

                        // Search & GoTo Logic

                        if (hasSelection) {
                            // 最多显示8个字，超出用省略号
                            const displayContent = selectedText.length > 8 ? selectedText.substring(0, 8) + '...' : selectedText;
                            if (ctxResultSearch) {
                                ctxResultSearch.style.display = 'flex';
                                const hint = document.getElementById('ctxResultSearchText');
                                if (hint) hint.textContent = displayContent;
                            }
                            if (ctxResultGoTo) {
                                if (isUrl) {
                                    ctxResultGoTo.style.display = 'flex';
                                    const hint = document.getElementById('ctxResultGoToUrl');
                                    if (hint) hint.textContent = displayContent;
                                } else {
                                    ctxResultGoTo.style.display = 'none';
                                }
                            }
                            if (ctxResultSearchSep) ctxResultSearchSep.style.display = 'block';
                        } else {
                            if (ctxResultSearch) ctxResultSearch.style.display = 'none';
                            if (ctxResultGoTo) ctxResultGoTo.style.display = 'none';
                            if (ctxResultSearchSep) ctxResultSearchSep.style.display = 'none';
                        }

                        resultContextMenu.style.left = `${x}px`;
                        resultContextMenu.style.top = `${y}px`;
                        resultContextMenu.classList.add('active');

                        // Close other menus
                        const editContextMenu = document.getElementById('editContextMenu');
                        if (editContextMenu) editContextMenu.classList.remove('active');
                    }
                }, true); // Capture phase
            }

            if (ctxResultSearch) {
                ctxResultSearch.addEventListener('click', () => {
                    const text = window.getSelection().toString().trim();
                    if (text) {
                        const url = `https://www.bing.com/search?q=${encodeURIComponent(text)}`;
                        window.open(url, '_blank');
                    }
                    if (resultContextMenu) resultContextMenu.classList.remove('active');
                });
            }

            if (ctxResultGoTo) {
                ctxResultGoTo.addEventListener('click', () => {
                    const text = window.getSelection().toString().trim();
                    if (text) {
                        window.open(text, '_blank');
                    }
                    if (resultContextMenu) resultContextMenu.classList.remove('active');
                });
            }

            if (ctxExportResult) {
                ctxExportResult.addEventListener('click', function () {
                    exportResult();
                    if (resultContextMenu) resultContextMenu.classList.remove('active');
                });
            }

            if (ctxResultCopy) {
                ctxResultCopy.addEventListener('click', function () {
                    document.execCommand('copy');
                    if (resultContextMenu) resultContextMenu.classList.remove('active');
                });
            }

            if (ctxResultSelectAll) {
                ctxResultSelectAll.addEventListener('click', function () {
                    const parsedText = document.getElementById('parsedText');
                    if (parsedText) {
                        const range = document.createRange();
                        range.selectNodeContents(parsedText);
                        const selection = window.getSelection();
                        selection.removeAllRanges();
                        selection.addRange(range);
                    }
                    if (resultContextMenu) resultContextMenu.classList.remove('active');
                });
            }

            // Close menu on click
            document.addEventListener('click', function (e) {
                if (resultContextMenu && resultContextMenu.classList.contains('active')) {
                    resultContextMenu.classList.remove('active');
                }
            });
        }

        async function exportResult(format = 'html') {
            if (window.exportManager) {
                await window.exportManager.exportResult(format);
            } else {
                console.error('ExportManager not loaded');
                showToast('导出模块加载失败', 'error');
            }
        }

        // Search Results Overlay Logic
        function getFaviconUrl(url) {
            try {
                const urlObj = new URL(url);
                return `https://ico.kucat.cn/get.php?url=${urlObj.hostname}&sz=32`;
            } catch (e) {
                return 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiM4ODgiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48Y2lyY2xlIGN4PSIxMiIgY3k9IjEyIiByPSIxMCI+PC9jaXJjbGU+PGxpbmUgeTE9IjEyIiB5Mj0iMTIiIHgxPSIxMiIgeDI9IjEyLjAxIj48L2xpbmU+PC9zdmc+'; // Fallback icon
            }
        }

        function toggleSearchResults(show, results = []) {
            const overlay = document.getElementById('searchResultsOverlay');
            const backdrop = document.getElementById('searchResultsBackdrop');
            const list = document.getElementById('searchResultsList');

            if (show) {
                list.innerHTML = '';

                results.forEach((item, index) => {
                    const el = document.createElement('div');
                    el.className = 'search-result-item';

                    let faviconUrl = '';
                    let hostname = '';
                    try {
                        const u = new URL(item.url);
                        hostname = u.hostname;
                        faviconUrl = getFaviconUrl(item.url);
                    } catch (e) {
                        hostname = '未知来源';
                    }

                    const formattedDate = item.date ? item.date.split('T')[0] : '未知日期';

                    el.innerHTML = `
                        <div class="search-item-index">${index + 1}</div>
                        <div class="search-item-header">
                            <img src="${faviconUrl}" class="search-item-favicon" onerror="this.style.display='none'" alt="icon">
                             <div class="search-item-content-wrapper">
                                <div class="search-item-title">${item.title}</div>
                                <div class="search-item-meta">
                                    <span>${hostname}</span>
                                    <span>${formattedDate}</span>
                                </div>
                             </div>
                        </div>
                        <div class="search-item-summary">${item.summary}</div>
                    `;

                    el.addEventListener('click', () => {
                        // 网页环境下，直接打开新窗口
                        window.open(item.url, '_blank');
                    });

                    list.appendChild(el);
                });

                overlay.classList.add('active');
                // backdrop.classList.add('active'); // Removed backdrop
                document.body.classList.add('search-results-active'); // Add squeeze class

                // 如果页面宽度支持同时显示三个页面，在开启搜索时将分隔线置为50%以防结果过小
                if (window.innerWidth >= 1200) {
                    const leftPanel = document.getElementById('leftPanel');
                    const rightPanel = document.getElementById('rightPanel');
                    if (leftPanel && rightPanel) {
                        leftPanel.style.flex = '0 0 50%';
                        rightPanel.style.flex = '1';
                        currentPercentage = 50;
                    }
                }

                // Trigger resize logic immediately to check if we need to hide left panel
                // Use requestAnimationFrame to ensure search-results-active transition starts first
                requestAnimationFrame(() => {
                    window.dispatchEvent(new Event('resize'));
                });
            } else {
                overlay.classList.remove('active');
                // backdrop.classList.remove('active'); // Removed backdrop
                document.body.classList.remove('search-results-active'); // Remove squeeze class

                // Always restore left panel and resizer when search results close
                const leftPanel = document.getElementById('leftPanel');

                // If we were in forced fullscreen mode, exit it to restore left panel
                if (document.body.classList.contains('detection-fullscreen')) {
                    const exitDetectionBtn = document.getElementById('exitDetectionBtn');
                    if (exitDetectionBtn) exitDetectionBtn.click(); // Reuse the smooth transition logic
                } else {
                    // Fallback just in case
                    if (leftPanel) leftPanel.style.display = '';
                }
            }
        }

        // Close handlers logic
        (function initSearchResultsEvents() {
            const closeBtn = document.getElementById('searchResultsClose');
            const panel = document.getElementById('searchResultsOverlay');

            if (closeBtn) closeBtn.addEventListener('click', () => toggleSearchResults(false));

            // Global click listener to close when clicking outside
            document.addEventListener('click', (e) => {
                // Requirement 1: Only close when clicking specific left sidebar areas
                // (including sidebar toggle, history button, preview button which refresh right interface)
                const panel = document.getElementById('searchResultsOverlay');
                if (!panel || !panel.classList.contains('active')) return;

                const sidebar = document.getElementById('leftSidebar');
                const toggleBtn = document.getElementById('sidebarToggleBtn');
                const previewBtn = document.getElementById('previewBtn');
                const historyBtn = document.getElementById('historyBtn');
                // Also batch mode toggle can refresh/change view
                const batchToggle = document.getElementById('batchModeToggle');

                const isClickInsidePanel = panel.contains(e.target);

                // If click is inside the search panel, do nothing (don't close)
                if (isClickInsidePanel) return;

                // Check if click target is one of the sidebar controls that should trigger close
                const isSidebarArea = (sidebar && sidebar.contains(e.target));
                const isToggleBtn = (toggleBtn && (toggleBtn === e.target || toggleBtn.contains(e.target)));
                const isPreviewBtn = (previewBtn && (previewBtn === e.target || previewBtn.contains(e.target)));
                const isHistoryBtn = (historyBtn && (historyBtn === e.target || historyBtn.contains(e.target)));
                const isBatchToggle = (batchToggle && (batchToggle === e.target || batchToggle.contains(e.target)));

                // If click is on these specific areas, close the search panel
                // Note: we mainly want to avoid closing when clicking on the Main Content Area (input/editor) 
                // unless the user explicitly interacts with navigation buttons.
                if (isSidebarArea || isToggleBtn || isPreviewBtn || isHistoryBtn || isBatchToggle) {
                    toggleSearchResults(false);
                }
            });

            // Prevent clicks inside the panel from closing it
            panel.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        })();

        // Monitor window resize to auto-collapse left panel when search results are open
        window.addEventListener('resize', () => {
            const panel = document.getElementById('searchResultsOverlay');
            const THRESHOLD_WIDTH = 1200;

            if (panel && panel.classList.contains('active')) {
                const shouldHide = window.innerWidth < THRESHOLD_WIDTH;
                const isFullscreen = document.body.classList.contains('detection-fullscreen');

                if (shouldHide && !isFullscreen) {
                    document.body.classList.add('detection-fullscreen');
                } else if (!shouldHide && isFullscreen) {
                    // Only restore (remove fullscreen) if we think it was auto-applied.
                    // But for simplicity/user request: "当窗口大于该值时...将会自动开启"
                    document.body.classList.remove('detection-fullscreen');
                    const leftPanel = document.getElementById('leftPanel');
                    const rightPanel = document.getElementById('rightPanel');
                    if (leftPanel) {
                        leftPanel.style.flex = '1';
                        currentPercentage = 50;
                    }
                    if (rightPanel) rightPanel.style.flex = '1';
                }
            }
        });

        // 初始化相关事件监听
        function initIPC() {
            // Setup SSE for real-time updates
            if (window.EventSource) {
                // Close existing if any
                if (window.appEventSource) {
                    window.appEventSource.close();
                }

                const eventSource = new EventSource('/api/events');
                window.appEventSource = eventSource;

                eventSource.onopen = () => {
                    console.log('SSE connected');
                };

                eventSource.addEventListener('status-update', (event) => {
                    try {
                        const { status, data } = JSON.parse(event.data);
                        console.log('Status Update Received:', status);

                        // Clear pending transition timeout
                        if (window.statusTextTimeout) {
                            clearTimeout(window.statusTextTimeout);
                            window.statusTextTimeout = null;
                        }

                        // Update global status variable for the progress bar animation loop
                        window.currentAnalysisStatus = status;

                        const loadingText = document.getElementById('loadingText');
                        if (!loadingText) return;

                        const updateText = (text) => {
                            loadingText.textContent = text;
                        };

                        if (status === 'extracting') {
                            updateText(data?.step === 'images' ? '正在为您加载并处理正文图片...' : '正在启动浏览器并提取网页内容...');
                        } else if (status === 'parsing') {
                            updateText('网页内容提取成功，正在解析...');
                        } else if (status === 'searching') {
                            window.searchStartTime = Date.now();
                            updateText(`正在联网搜索: ${data?.query || ''}`);
                            // Limit display of search query to max 5 seconds
                            window.statusTextTimeout = setTimeout(() => {
                                if (window.currentAnalysisStatus === 'searching') {
                                    updateText('正在进行深度分析...');
                                }
                            }, 5000);
                        } else if (status === 'search-failed') {
                            updateText('联网搜索失败，正在进行离线分析...');
                        } else if (status === 'deep-analysis') {
                            const elapsed = Date.now() - (window.searchStartTime || 0);
                            const minDisplay = 4000;
                            
                            if (elapsed < minDisplay && window.searchStartTime) {
                                // If the search keyword was shown for too short, wait until 4s is reached
                                window.statusTextTimeout = setTimeout(() => {
                                    updateText('正在进行深度分析...');
                                }, minDisplay - elapsed);
                            } else {
                                updateText('正在进行深度分析...');
                            }
                        } else {
                            updateText('AI 正在分析中，请稍候...');
                        }
                    } catch (e) {
                        console.error('Failed to parse status update', e);
                    }
                });

                eventSource.onerror = (err) => {
                    // console.error('SSE Error:', err);
                    // EventSource automatically reconnects
                };
            }
        }

        // 恢复右侧界面至初始状态
        function resetRightPanel() {
            const initialState = document.getElementById('initialState');
            const resultItem = document.getElementById('resultItem');
            const errorState = document.getElementById('errorState');
            const loadingState = document.getElementById('loadingState');

            if (initialState) {
                initialState.style.display = 'flex';
                initialState.classList.add('active');
            }
            if (resultItem) {
                resultItem.style.display = 'none';
                resultItem.classList.remove('active');
            }
            if (errorState) {
                errorState.style.display = 'none';
                errorState.classList.remove('active');
            }
            if (loadingState) {
                loadingState.style.display = 'none';
                loadingState.classList.remove('active');
            }
        }

        // 清空编辑器内容
        function clearEditorContent(showToastMessage = true) {
            const textInput = document.getElementById('textInput');
            if (textInput) {
                textInput.innerText = '';
            }

            uploadedImages = [];
            if (typeof selectedImages !== 'undefined' && selectedImages instanceof Set) {
                selectedImages.clear();
            }
            if (typeof detectedUrls !== 'undefined') {
                detectedUrls = [];
            }

            const imagePreview = document.getElementById('imagePreview');
            if (imagePreview) {
                imagePreview.innerHTML = '';
            }
            if (typeof renderImages === 'function') {
                renderImages();
            }

            updateEditorStats();
            if (typeof updateBtnState === 'function') {
                updateBtnState();
            }

            resetRightPanel();

            if (showToastMessage) {
                showToast('内容已清空', 'success');
            }
        }

        // 显示检测结果
        function showResult() {
            const initialState = document.getElementById('initialState');
            const resultItem = document.getElementById('resultItem');
            const parsedContent = document.getElementById('parsedContent');
            const parsedTitle = document.getElementById('parsedTitle');
            const parsedText = document.getElementById('parsedText');
            const parsedImages = document.getElementById('parsedImages');

            // 获取输入内容
            const textContent = document.getElementById('textInput').innerText.trim();

            // 随机生成分数
            const score = Math.floor(Math.random() * 40) + 20;
            const scoreText = document.getElementById('scoreText');
            const scoreValue = document.getElementById('scoreValue');
            const scoreDescription = document.getElementById('scoreDescription');
            const scoreProgress = document.getElementById('scoreProgress');
            const scoreContainer = document.getElementById('scoreCircleContainer');

            scoreText.textContent = score + '%';
            scoreValue.textContent = score + '%';

            // Reset classes
            scoreContainer.className = 'score-circle-container';

            if (score >= 80) {
                scoreContainer.classList.add('real');
                scoreDescription.textContent = '该内容具有较高的可信度';
            } else if (score >= 60) {
                scoreContainer.classList.add('uncertain');
                scoreDescription.textContent = '该内容存在一定的不确定性';
            } else {
                scoreContainer.classList.add('fake');
                scoreDescription.textContent = '该内容可能存在虚假信息';
            }

            // Animate Progress
            const circumference = 2 * Math.PI * 45; // r=45
            const offset = circumference - (score / 100) * circumference;
            scoreProgress.style.strokeDashoffset = circumference; // Reset first
            setTimeout(() => {
                scoreProgress.style.strokeDashoffset = offset;
            }, 100);

            // 显示输入内容
            parsedContent.style.display = 'block';
            parsedTitle.style.display = 'none'; // 纯文本输入无标题
            parsedText.textContent = textContent;

            // 渲染上传的图片
            parsedImages.innerHTML = '';
            if (uploadedImages.length > 0) {
                uploadedImages.forEach(img => {
                    const item = document.createElement('div');
                    item.className = 'parsed-image-item';
                    item.innerHTML = `<img src="${img.url}" alt="${img.name}">`;
                    // 允许从解析区域拖动到左侧（传递图片 URL）
                    item.setAttribute('draggable', 'true');
                    item.addEventListener('dragstart', (ev) => {
                        try {
                            ev.dataTransfer.setData('text/uri-list', img.url);
                            ev.dataTransfer.setData('text/plain', img.url);
                            ev.dataTransfer.effectAllowed = 'copy';
                        } catch (e) { }
                    });
                    item.addEventListener('click', () => showImageModal(img.url));
                    parsedImages.appendChild(item);
                });
            }

            initialState.style.display = 'none';
            resultItem.classList.add('active');
        }

        // 将图片转换为 Base64 以解决显示问题
        async function convertImagesToBase64(container) {
            if (!container) return;
            const images = container.querySelectorAll('img');
            for (const img of images) {
                const originalSrc = img.getAttribute('data-original-src') || img.src;

                // 跳过已经是 base64 的图片或已经转换过的
                if (!originalSrc || originalSrc.startsWith('data:') || img.getAttribute('data-converted') === 'true') {
                    continue;
                }

                // 优化：直接使用代理 URL 代替 Base64 转换。
                // 这样可以利用浏览器和服务器的双方缓存，同时显著提高加载速度。
                let displaySrc = originalSrc;
                if (displaySrc && !displaySrc.startsWith('blob:')) {
                    displaySrc = getProxyUrl(displaySrc);
                    img.src = displaySrc;
                    img.setAttribute('data-converted', 'true');
                    img.style.opacity = '1';
                }
            }
        }

        // 绑定图片点击事件，使用最新的 img.src 打开大图，避免转换为 base64 后仍使用旧 URL
        function bindImagePreview(container) {
            if (!container) return;
            const items = container.querySelectorAll('.parsed-image-item');
            items.forEach(item => {
                const img = item.querySelector('img');
                if (!img) return;

                const reason = item.getAttribute('data-reason') || img.getAttribute('data-reason') || null;

                const handler = (e) => {
                    e.stopPropagation();
                    showImageModal(img.src, reason);
                };

                // 覆盖绑定，避免重复叠加
                item.onclick = handler;
                img.onclick = handler;
            });
        }

        // 显示提取结果
        function showExtractedResult(result) {
            const loadingState = document.getElementById('loadingState');
            const resultItem = document.getElementById('resultItem');
            const parsedContent = document.getElementById('parsedContent');
            const parsedTitle = document.getElementById('parsedTitle');
            const parsedText = document.getElementById('parsedText');
            const parsedImages = document.getElementById('parsedImages');

            loadingState.classList.remove('active');

            // 更新结果显示
            const scoreText = document.getElementById('scoreText');
            const scoreValue = document.getElementById('scoreValue');
            const scoreDescription = document.getElementById('scoreDescription');
            const scoreProgress = document.getElementById('scoreProgress');
            const scoreContainer = document.getElementById('scoreCircleContainer');

            // 使用随机分数作为示例
            const score = Math.floor(Math.random() * 40) + 60;
            scoreText.textContent = score + '%';
            scoreValue.textContent = score + '%';

            // Reset classes
            scoreContainer.className = 'score-circle-container';

            if (score >= 80) {
                scoreContainer.classList.add('real');
                scoreDescription.textContent = '该内容具有较高的可信度';
            } else if (score >= 60) {
                scoreContainer.classList.add('uncertain');
                scoreDescription.textContent = '该内容存在一定的不确定性';
            } else {
                scoreContainer.classList.add('fake');
                scoreDescription.textContent = '该内容可能存在虚假信息';
            }

            // Animate Progress
            const circumference = 2 * Math.PI * 45; // r=45
            const offset = circumference - (score / 100) * circumference;
            scoreProgress.style.strokeDashoffset = circumference; // Reset first
            setTimeout(() => {
                scoreProgress.style.strokeDashoffset = offset;
            }, 100);

            // 显示解析内容
            parsedContent.style.display = 'block';
            parsedTitle.textContent = result.title || '无标题';
            parsedTitle.style.display = result.title ? 'block' : 'none';
            parsedText.innerHTML = result.content || '';
            parsedText.classList.add('is-html');

            // 异步转换为 base64 以解决破碎问题
            convertImagesToBase64(parsedText);
            bindImagePreview(parsedText);

            // 渲染图片
            parsedImages.innerHTML = '';
            if (result.images && result.images.length > 0) {
                // Remove duplicates and limit to 4
                const uniqueImages = [...new Set(result.images)].slice(0, 4);

                uniqueImages.forEach(imgUrl => {
                    if (!imgUrl) return;

                    const item = document.createElement('div');
                    item.className = 'parsed-image-item';

                    // If it's already a proxy URL, don't wrap it again
                    // Add a cache-busting timestamp if needed, but for now just ensure correct encoding
                    const proxyUrl = imgUrl.startsWith('/api/proxy-image') ?
                        imgUrl : `/api/proxy-image?url=${encodeURIComponent(imgUrl)}`;

                    item.innerHTML = `<img src="${proxyUrl}" data-original-src="${imgUrl}" alt="图片" referrerpolicy="no-referrer" onerror="this.onerror=null; this.src='/ico/Detect.ico'; this.style.opacity='0.4';">`;

                    item.setAttribute('draggable', 'true');
                    item.addEventListener('dragstart', (ev) => {
                        try {
                            ev.dataTransfer.setData('text/uri-list', proxyUrl);
                            ev.dataTransfer.setData('text/plain', proxyUrl);
                            ev.dataTransfer.effectAllowed = 'copy';
                        } catch (e) { }
                    });
                    item.addEventListener('click', () => showImageModal(proxyUrl));
                    parsedImages.appendChild(item);
                });

                // 异步转换为 base64 以解决破碎问题
                convertImagesToBase64(parsedImages);
                bindImagePreview(parsedImages);
            }

            resultItem.classList.add('active');
            resultItem.style.display = 'block'; // Ensure visible
        }

        function showError(message) {
            const errorState = document.getElementById('errorState');
            const errorDetail = document.getElementById('errorDetail');
            const loadingState = document.getElementById('loadingState');
            const resultItem = document.getElementById('resultItem');
            const initialState = document.getElementById('initialState');
            const detectBtn = document.getElementById('detectBtn');

            if (initialState) initialState.style.display = 'none';
            if (resultItem) resultItem.style.display = 'none';
            loadingState.classList.remove('active');
            detectBtn.classList.remove('loading');
            detectBtn.innerHTML = '开始检测';

            errorDetail.textContent = message || '无法获取网页内容，请检查链接是否有效';
            errorState.classList.add('active');
        }

        // 图片模态框
        function initModal() {
            const modal = document.getElementById('imageModal');
            const modalClose = document.getElementById('modalClose');
            const modalImage = document.getElementById('modalImage');

            modalClose.addEventListener('click', function () {
                modal.classList.remove('active');
            });

            modal.addEventListener('click', function (e) {
                if (e.target === modal) {
                    modal.classList.remove('active');
                }
            });
        }

        function showImageModal(url, reason = null) {
            const modal = document.getElementById('imageModal');
            const modalImage = document.getElementById('modalImage');
            const modalReason = document.getElementById('modalReason');

            modalImage.src = url;

            if (reason) {
                modalReason.textContent = reason;
                modalReason.classList.add('active');
            } else {
                modalReason.classList.remove('active');
            }

            modal.classList.add('active');
        }

        // Toast 提示
        let toastTimer = null;
        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;

            if (toastTimer) clearTimeout(toastTimer);

            setTimeout(() => {
                toast.classList.add('show');
            }, 10);

            if (duration > 0) {
                toastTimer = setTimeout(() => {
                    toast.classList.remove('show');
                }, duration);
            }
        }

        function hideToast() {
            const toast = document.getElementById('toast');
            if (toast) {
                toast.classList.remove('show');
                if (toastTimer) clearTimeout(toastTimer);
            }
        }


        // 新闻AI分析功能
        async function analyzeContent(text, images, fromExtraction = false, htmlContent = null) {
            const detectBtn = document.getElementById('detectBtn');
            const previewBtn = document.getElementById('previewBtn');
            const loadingState = document.getElementById('loadingState');
            const initialState = document.getElementById('initialState');
            const resultItem = document.getElementById('resultItem');
            const errorState = document.getElementById('errorState');
            const progressBar = document.getElementById('progressBar');
            const loadingText = document.getElementById('loadingText');

            // 禁用按钮防止重复点击
            if (detectBtn) {
                detectBtn.disabled = true;
                detectBtn.style.opacity = '0.5';
                detectBtn.style.pointerEvents = 'none';
            }
            if (previewBtn) {
                previewBtn.disabled = true;
                previewBtn.style.opacity = '0.5';
                previewBtn.style.pointerEvents = 'none';
            }

            // UI Loading State
            initialState.style.display = 'none';
            resultItem.classList.remove('active');
            resultItem.style.display = 'none'; // Ensure hidden during loading
            errorState.classList.remove('active');
            loadingState.classList.add('active');
            detectBtn.classList.add('loading');
            detectBtn.innerHTML = '分析中...';

            // 设置进度条初始状态
            let progress = fromExtraction ? 20 : 0;
            progressBar.style.width = progress + '%';
            loadingText.textContent = '正在初始化分析...';

            // 初始化分析状态标记
            window.currentAnalysisStatus = 'initializing';

            // 模拟分析阶段的进度增长
            // 阶段定义: 初始化(0-40%) -> 联网搜索(40-70%) -> 深度分析(70-90%)
            let statusTimer = 0;
            const progressInterval = setInterval(() => {
                statusTimer += 80;
                // If we don't receive real-time updates from server, we simulate status changes to make UI feel alive
                if (statusTimer > 3000 && window.currentAnalysisStatus === 'initializing') {
                    window.currentAnalysisStatus = 'searching';
                }
                if (statusTimer > 8000 && window.currentAnalysisStatus === 'searching') {
                    window.currentAnalysisStatus = 'deep-analysis';
                }

                let targetMax = 40; // 默认停在初始化阶段末尾

                // 根据后台返回的实际状态决定进度上限
                if (window.currentAnalysisStatus === 'searching') {
                    targetMax = 70;
                } else if (window.currentAnalysisStatus === 'deep-analysis') {
                    // 如果不需要搜索或者搜索已完成，允许进度到达深度分析阶段
                    targetMax = 91;
                }

                if (progress < targetMax) {
                    // 速度控制，让增长显得自然
                    let increment = (progress < 20) ? 0.6 : (progress < 40) ? 0.3 : (progress < 70) ? 0.2 : 0.1;

                    progress += increment;
                    if (progress > 91) progress = 91;

                    progressBar.style.width = Math.min(progress, 90) + '%';
                }
            }, 80);

            try {
                let imageUrls = [];
                if (images && images.length > 0) {
                    // 限制最多4张图片
                    const limitedImages = images.slice(0, 4);
                    imageUrls = limitedImages.map(img => typeof img === 'string' ? img : img.url);
                }

                let result;
                // 检查是否是URL提取的内容，如果是，尝试获取URL
                let sourceUrl = '';
                if (fromExtraction && window.lastExtractedUrl) {
                    sourceUrl = window.lastExtractedUrl;
                } else if (isURL(text)) {
                    sourceUrl = text;
                }

                // Call unified API bridge
                const response = await api.invoke('analyze-content', { text, imageUrls, url: sourceUrl });
                if (response) {
                    // Backend might return {success, data} or raw object
                    result = response.data || response;
                } else {
                    throw new Error('无法获取分析结果');
                }

                clearInterval(progressInterval);
                progressBar.style.width = '100%';

                // 稍微延迟一下让用户看到100%
                setTimeout(() => {
                    try {
                        showAnalysisResult(result, htmlContent || text, images, !!htmlContent);
                        showToast('分析完成', 'success');
                    } catch (renderError) {
                        console.error('Render Error:', renderError);
                        showError('结果渲染失败: ' + renderError.message);
                    } finally {
                        loadingState.classList.remove('active');
                        loadingState.style.display = 'none'; // 强制隐藏
                        detectBtn.classList.remove('loading');
                        detectBtn.innerHTML = '开始检测';

                        // Re-enable buttons
                        if (detectBtn) {
                            detectBtn.disabled = false;
                            detectBtn.style.opacity = '1';
                            detectBtn.style.pointerEvents = 'auto';
                        }
                        if (previewBtn) {
                            previewBtn.disabled = false;
                            previewBtn.style.opacity = '1';
                            previewBtn.style.pointerEvents = 'auto';
                        }
                        
                        // Clear any lingering status status text timeout
                        if (window.statusTextTimeout) {
                            clearTimeout(window.statusTextTimeout);
                            window.statusTextTimeout = null;
                        }
                    }

                    // 保存到历史记录 - 在 UI 回复后再进行，确保不阻塞显示
                    saveToHistory(htmlContent || text, result, images, !!htmlContent);
                }, 500);

            } catch (error) {
                clearInterval(progressInterval);
                console.error(error);
                showError('AI分析失败: ' + error.message);
                showToast('分析失败', 'error');
                loadingState.classList.remove('active');
                loadingState.style.display = 'none'; // 强制隐藏
                detectBtn.classList.remove('loading');
                detectBtn.innerHTML = '开始检测';

                // Re-enable buttons
                if (detectBtn) {
                    detectBtn.disabled = false;
                    detectBtn.style.opacity = '1';
                    detectBtn.style.pointerEvents = 'auto';
                }
                if (previewBtn) {
                    previewBtn.disabled = false;
                    previewBtn.style.opacity = '1';
                    previewBtn.style.pointerEvents = 'auto';
                }
            }
        }

        function showAnalysisResult(result, originalText, originalImages, isHtml = false) {
            const resultItem = document.getElementById('resultItem');
            const initialState = document.getElementById('initialState');
            if (initialState) initialState.style.display = 'none';
            resultItem.style.display = 'block'; // Ensure visible
            resultItem.classList.add('active'); // Ensure active class
            const parsedContent = document.getElementById('parsedContent');
            const parsedTitle = document.getElementById('parsedTitle');
            const parsedText = document.getElementById('parsedText');
            const parsedImages = document.getElementById('parsedImages');

            // Ensure Score and Analysis are visible (in case they were hidden by preview)
            const scoreSection = resultItem.querySelector('.result-score');
            const analysisSection = resultItem.querySelector('.result-analysis');
            if (scoreSection) scoreSection.style.display = 'flex';
            if (analysisSection) analysisSection.style.display = 'block';

            const scoreText = document.getElementById('scoreText');
            const scoreValue = document.getElementById('scoreValue');
            const scoreDescription = document.getElementById('scoreDescription');
            const scoreProgress = document.getElementById('scoreProgress');
            const scoreContainer = document.getElementById('scoreCircleContainer');

            // Probability to Percentage
            const percentage = Math.round(result.probability * 100);
            scoreText.textContent = percentage + '%';
            scoreValue.textContent = percentage + '%';

            // Reset classes
            scoreContainer.className = 'score-circle-container';

            // Color logic based on percentage
            if (percentage >= 75) {
                scoreContainer.classList.add('real');
            } else if (percentage >= 50) {
                scoreContainer.classList.add('uncertain');
            } else {
                scoreContainer.classList.add('fake');
            }

            // Animate Progress
            const circumference = 2 * Math.PI * 45; // r=45
            const offset = circumference - (percentage / 100) * circumference;
            scoreProgress.style.strokeDashoffset = circumference; // Reset first
            setTimeout(() => {
                scoreProgress.style.strokeDashoffset = offset;
            }, 100);

            // Type handling for description
            if (result.type === 1) { // True
                scoreDescription.innerHTML = `<strong>可信度高</strong><br>${result.explanation}`;
            } else if (result.type === 2) { // Partial
                scoreDescription.innerHTML = `<strong>真假参半</strong><br>${result.explanation}`;
            } else { // Fake
                scoreDescription.innerHTML = `<strong>虚假消息</strong><br>${result.explanation}`;
            }

            // Update Analysis Points
            const analysisContainer = document.querySelector('.result-analysis');
            // 清空旧的静态内容（保留标题）
            const analysisTitle = analysisContainer.querySelector('.analysis-title');
            analysisContainer.innerHTML = '';
            analysisContainer.appendChild(analysisTitle);

            if (result.analysis_points && Array.isArray(result.analysis_points)) {
                result.analysis_points.forEach((point, index) => {
                    const item = document.createElement('div');
                    item.className = 'analysis-item';

                    let icon = '✓';
                    let iconClass = 'positive';

                    if (point.status === 'warning') {
                        icon = '!';
                        iconClass = 'warning';
                    } else if (point.status === 'negative') {
                        icon = '✕';
                        iconClass = 'negative';
                    }

                    item.innerHTML = `
                        <div class="analysis-icon ${iconClass}">${icon}</div>
                        <div class="analysis-text">${point.description}</div>
                    `;

                    // Only bind click event to the first item if there are search results
                    if (index === 0 && result.search_results && Array.isArray(result.search_results) && result.search_results.length > 0) {
                        item.style.cursor = 'pointer';
                        item.title = '点击查看搜索来源';

                        // Add an indication icon
                        const linkIcon = document.createElement('div');
                        linkIcon.style.display = 'flex';
                        linkIcon.style.alignItems = 'center';
                        linkIcon.style.marginTop = '4px';
                        linkIcon.style.fontSize = '12px';
                        linkIcon.style.opacity = '0.7';
                        linkIcon.style.color = 'var(--text-secondary)';
                        linkIcon.innerHTML = `🔗 (已引用${result.search_results.length}个结果)`;
                        item.querySelector('.analysis-text').appendChild(linkIcon);

                        item.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleSearchResults(true, result.search_results);
                        });
                    }

                    analysisContainer.appendChild(item);
                });
            } else {
                // Fallback if no analysis points provided
                analysisContainer.innerHTML += `<div class="analysis-item"><div class="analysis-text">暂无详细分析点</div></div>`;
            }

            // Display Content
            parsedContent.style.display = 'block';
            if (result.title) {
                parsedTitle.textContent = result.title;
                parsedTitle.style.display = 'block';
            } else {
                parsedTitle.style.display = 'none';
            }

            if (isHtml) {
                parsedText.classList.add('is-html');
            } else {
                parsedText.classList.remove('is-html');
            }

            // Highlight fake parts
            let displayText = originalText;
            if (result && (result.type === 2 || result.type === 3) && result.fake_parts && Array.isArray(result.fake_parts)) {
                if (isHtml) {
                    let safeText = displayText;
                    // Sort fake parts by length descending to avoid nested replacement issues
                    const sortedParts = [...result.fake_parts].sort((a, b) => (b.text || '').length - (a.text || '').length);
                    sortedParts.forEach(part => {
                        if (part.text && safeText.includes(part.text)) {
                            // Ensure we only replace once per call to avoid double highlights
                            // and escape quotes for attribute
                            const reasonObj = {
                                r: part.risk_type || '内容存疑',
                                d: part.reason || ''
                            };
                            const reasonStr = JSON.stringify(reasonObj).replace(/"/g, '&quot;');
                            const highlight = `<span class="fake-highlight" data-reason="${reasonStr}" onclick="showReasonTooltip(event, this, 'click')" onmouseenter="showReasonTooltip(event, this, 'hover')" onmouseleave="hideTooltip(false)">${part.text}</span>`;
                            safeText = safeText.replace(part.text, highlight);
                        }
                    });
                    parsedText.innerHTML = safeText;
                } else {
                    let safeText = (displayText || '').replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");

                    const sortedParts = [...result.fake_parts].sort((a, b) => (b.text || '').length - (a.text || '').length);

                    sortedParts.forEach(part => {
                        if (part.text) {
                            const safePart = part.text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                            const reasonObj = {
                                r: part.risk_type || '内容存疑',
                                d: part.reason || ''
                            };
                            const reasonStr = JSON.stringify(reasonObj).replace(/"/g, '&quot;');
                            const highlight = `<span class="fake-highlight" data-reason="${reasonStr}" onclick="showReasonTooltip(event, this, 'click')" onmouseenter="showReasonTooltip(event, this, 'hover')" onmouseleave="hideTooltip(false)">${safePart}</span>`;
                            safeText = safeText.replace(safePart, highlight);
                        }
                    });
                    parsedText.innerHTML = safeText;
                }
            } else {
                if (isHtml) {
                    parsedText.innerHTML = originalText || '';
                } else {
                    parsedText.textContent = originalText || '';
                }
            }

            // 异步转换为 base64 以解决破碎问题
            convertImagesToBase64(parsedText);
            bindImagePreview(parsedText);

            // Render Images in Result
            parsedImages.innerHTML = '';

            const uniqueImages = new Map();
            if (originalImages && Array.isArray(originalImages)) {
                originalImages.forEach(img => {
                    let url, name;
                    if (typeof img === 'string') {
                        url = img;
                        name = 'Image';
                    } else if (img && typeof img === 'object') {
                        url = img.url;
                        name = img.name || 'Image';
                    }

                    if (url && !uniqueImages.has(url)) {
                        // Directly use URL as src to save server bandwidth
                        uniqueImages.set(url, { url, src: url, name });
                    }
                });
            }

            if (uniqueImages.size > 0) {
                // 添加标题
                const title = document.createElement('div');
                title.className = 'parsed-images-title';
                title.textContent = '引用的图片';
                parsedImages.appendChild(title);

                // 添加分隔线
                const separator = document.createElement('div');
                separator.style.height = '1px';
                separator.style.backgroundColor = 'var(--border-color)';
                separator.style.margin = '8px 0 12px 0';
                separator.style.width = '100%';
                parsedImages.appendChild(separator);

                // 创建图片容器
                const imgContainer = document.createElement('div');
                imgContainer.className = 'parsed-images';

                uniqueImages.forEach((imgObj) => {
                    const item = document.createElement('div');
                    item.className = 'parsed-image-item';

                    // 使用后端代理所有非 base64 图片以绕过热链检查
                    let displaySrc = imgObj.src;
                    if (displaySrc && !displaySrc.startsWith('data:') && !displaySrc.startsWith('blob:')) {
                        displaySrc = `/api/proxy-image?url=${encodeURIComponent(displaySrc)}`;
                    }

                    item.innerHTML = `<img src="${displaySrc}" data-original-src="${imgObj.url}" alt="${imgObj.name}" onerror="this.onerror=null; this.src='/ico/Detect.ico'; this.style.opacity='0.4';">`;

                    // 标记虚假图片并添加交互
                    const fakeData = (result.fake_images && Array.isArray(result.fake_images)) ?
                        result.fake_images.find(fi => fi.url === imgObj.url) : null;
                    // ... (some lines omitted)
                    imgContainer.appendChild(item);
                });

                parsedImages.appendChild(imgContainer);

                // 异步转换为 base64 以解决破碎问题
                convertImagesToBase64(imgContainer);
                bindImagePreview(imgContainer);
            }

            resultItem.classList.add('active');
        }

        // Tooltip Logic
        let activeTooltipElement = null;
        let tooltipUpdateRaf = null;
        let tooltipIsLocked = false;

        function updateTooltipPosition() {
            const tooltip = document.getElementById('customTooltip');
            if (!tooltip || !tooltip.classList.contains('active') || !activeTooltipElement) return;

            const rect = activeTooltipElement.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();

            // Calculate position (centered horizontally, below element)
            let top = rect.bottom + 10;
            let left = rect.left + (rect.width / 2) - (tooltipRect.width / 2);

            // Viewport boundary checks
            const padding = 16;

            // Horizontal check
            if (left < padding) {
                left = padding;
            } else if (left + tooltipRect.width > window.innerWidth - padding) {
                left = window.innerWidth - tooltipRect.width - padding;
            }

            // Vertical check (flip to top if not enough space below)
            if (top + tooltipRect.height > window.innerHeight - padding) {
                top = rect.top - tooltipRect.height - 10;
            }

            tooltip.style.top = `${top}px`;
            tooltip.style.left = `${left}px`;
        }

        function showReasonTooltip(event, element, mode = 'click') {
            if (event) event.stopPropagation();

            // If it's a hover and we are locked, only change if it's the SAME element (to update content if needed)
            // or if we want hover to override lock? User said "保留原有鼠标点击逻辑".
            // Original logic hides previous when showing new.
            if (mode === 'hover' && tooltipIsLocked && activeTooltipElement !== element) {
                return;
            }

            if (mode === 'click') {
                tooltipIsLocked = true;
            }

            // Remove active class from previous highlight
            if (activeTooltipElement && activeTooltipElement !== element) {
                activeTooltipElement.classList.remove('active');
            }

            const reasonAttr = element.getAttribute('data-reason');
            if (!reasonAttr) return;

            activeTooltipElement = element;
            activeTooltipElement.classList.add('active');

            let tooltip = document.getElementById('customTooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'customTooltip';
                tooltip.className = 'custom-tooltip';
                document.body.appendChild(tooltip);
            }

            // Handle both legacy (string) and new (JSON) formats
            let riskType = '内容存疑';
            let description = reasonAttr;
            let originalText = element.textContent;

            try {
                if (reasonAttr.startsWith('{')) {
                    const data = JSON.parse(reasonAttr);
                    riskType = data.r || riskType;
                    description = data.d || '';
                }
            } catch (e) {
                console.warn('Failed to parse tooltip JSON', e);
            }

            tooltip.innerHTML = `
                <div class="tooltip-header">风险详情</div>
                <div class="tooltip-section">
                    <div class="tooltip-label">风险类型</div>
                    <div class="tooltip-tag">${riskType}</div>
                </div>
                <div class="tooltip-section">
                    <div class="tooltip-label">检测原文</div>
                    <div class="tooltip-quote">"${originalText}"</div>
                </div>
                <div class="tooltip-section">
                    <div class="tooltip-label">AI 分析理由</div>
                    <div class="tooltip-reason">${description}</div>
                </div>
            `;
            tooltip.classList.add('active');

            // Initial position update
            updateTooltipPosition();
        }

        function hideTooltip(force = true) {
            // If not force, and locked, don't hide
            if (!force && tooltipIsLocked) return;

            if (force) {
                tooltipIsLocked = false;
            }

            const tooltip = document.getElementById('customTooltip');
            if (tooltip) {
                tooltip.classList.remove('active');
            }
            if (activeTooltipElement) {
                activeTooltipElement.classList.remove('active');
                activeTooltipElement = null;
            }
        }

        // Global event listeners for tooltip management
        document.addEventListener('click', function (e) {
            // Clear image selection if clicking outside
            if (selectedImages.size > 0) {
                // Since image click stops propagation, any click reaching here is outside an image
                // (or on an element that bubbled up, but not an image item)
                selectedImages.clear();
                renderImages();
            }

            const tooltip = document.getElementById('customTooltip');
            // If clicking inside tooltip, do nothing
            if (tooltip && tooltip.contains(e.target)) {
                return;
            }
            // If clicking a highlight, it's handled by onclick
            if (e.target.classList.contains('fake-highlight')) {
                return;
            }

            hideTooltip();
        });

        // Update position on scroll and resize
        // Use capture to catch scroll events from any container
        window.addEventListener('scroll', function () {
            if (activeTooltipElement) {
                if (tooltipUpdateRaf) cancelAnimationFrame(tooltipUpdateRaf);
                tooltipUpdateRaf = requestAnimationFrame(updateTooltipPosition);
            }
        }, true);

        window.addEventListener('resize', function () {
            if (activeTooltipElement) {
                updateTooltipPosition();
            }
        });
        // Sidebar Toggle Logic
        const sidebarToggleBtn = document.getElementById('sidebarToggleBtn');
        const historyBtn = document.getElementById('historyBtn');
        const leftSidebar = document.getElementById('leftSidebar');

        function toggleSidebar(forceState) {
            if (!leftSidebar) return;

            const isExpanded = typeof forceState === 'boolean'
                ? forceState
                : !leftSidebar.classList.contains('expanded');

            if (isExpanded) {
                leftSidebar.classList.add('expanded');
                document.body.classList.add('sidebar-expanded');
                // Close search results when sidebar opens
                toggleSearchResults(false);
            } else {
                leftSidebar.classList.remove('expanded');
                document.body.classList.remove('sidebar-expanded');
            }
        }

        if (sidebarToggleBtn) {
            sidebarToggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleSidebar();
            });
        }

        if (historyBtn) {
            historyBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // History button reuses expand function
                toggleSidebar(true);
            });
        }

        // New Chat Button Logic
        const newChatBtn = document.getElementById('newChatBtn');
        if (newChatBtn) {
            newChatBtn.addEventListener('click', (e) => {
                e.stopPropagation();

                if (isBatchMode) {
                    // In Batch Mode: Add new item and jump to it
                    const newId = addBatchItem('', []);
                    renderBatchList();
                    enterBatchEditMode(newId);
                    return;
                }

                // Reset UI to initial state without clearing text input
                const resultItem = document.getElementById('resultItem');
                const initialState = document.getElementById('initialState');
                const loadingState = document.getElementById('loadingState');
                const errorState = document.getElementById('errorState');
                const progressBar = document.getElementById('progressBar');
                const statusText = document.getElementById('statusText');
                const imagePreview = document.getElementById('imagePreview');
                const urlInput = document.getElementById('urlInput');

                if (resultItem) resultItem.style.display = 'none';
                if (initialState) initialState.style.display = 'flex';
                if (loadingState) loadingState.classList.remove('active');
                if (errorState) errorState.classList.remove('active');

                if (progressBar) {
                    progressBar.style.width = '0%';
                    // 不要隐藏 parentElement，否则下次加载时进度条会丢失
                    // progressBar.parentElement.style.display = 'none'; 
                }

                if (statusText) statusText.textContent = '';

                if (imagePreview) {
                    // 修正：不要隐藏容器，而是清空内容
                    imagePreview.innerHTML = '';
                    // 重置上传图片数组
                    uploadedImages = [];
                    selectedImages.clear();
                    updateEditorStats();
                    // 清除文件输入框的值
                    const fileInput = document.getElementById('fileInput');
                    if (fileInput) fileInput.value = '';
                }

                if (urlInput) urlInput.value = '';

                // Reset current history item tracking
                currentHistoryItem = null;
            });
        }

        // Global listener to collapse when clicking outside (left or right click)
        function handleOutsideClick(e) {
            if (!leftSidebar || !leftSidebar.classList.contains('expanded')) return;

            // Check if click is inside sidebar or toggle button
            const isInsideSidebar = leftSidebar.contains(e.target);
            const isToggleButton = sidebarToggleBtn && sidebarToggleBtn.contains(e.target);

            // Check if click is inside context menu or modal
            const historyContextMenu = document.getElementById('historyContextMenu');
            const isInsideHistoryMenu = historyContextMenu && historyContextMenu.contains(e.target);

            const batchContextMenu = document.getElementById('batchContextMenu');
            const isInsideBatchMenu = batchContextMenu && batchContextMenu.contains(e.target);

            const customModal = document.getElementById('customModal');
            const isInsideModal = customModal && customModal.classList.contains('active') && customModal.contains(e.target);

            if (!isInsideSidebar && !isToggleButton && !isInsideHistoryMenu && !isInsideBatchMenu && !isInsideModal) {
                toggleSidebar(false);
            }
        }

        document.addEventListener('mousedown', handleOutsideClick);
        document.addEventListener('contextmenu', handleOutsideClick);

        // --- History Management ---
        let allHistory = [];
        let currentHistoryPage = 1;
        let historyLoading = false;
        let hasMoreHistory = true;
        const historyLimit = 20;
        let currentHistoryItem = null; // For context menu

        async function loadHistory(isLoadMore = false) {
            if (historyLoading) return;
            if (isLoadMore && !hasMoreHistory) return;

            historyLoading = true;
            if (!isLoadMore) {
                currentHistoryPage = 1;
                hasMoreHistory = true;
            }

            try {
                // Modified: Only load metadata initially with pagination
                const result = await api.invoke('get-history', { 
                    metadataOnly: true, 
                    page: currentHistoryPage, 
                    limit: historyLimit 
                });
                
                const data = result.data || [];
                hasMoreHistory = result.hasMore;

                if (isLoadMore) {
                    allHistory = allHistory.concat(data);
                } else {
                    allHistory = data;
                }
                
                renderHistory();
                currentHistoryPage++;
            } catch (err) {
                console.error('Failed to load history:', err);
                if (!isLoadMore) {
                    allHistory = [];
                    renderHistory();
                }
            } finally {
                historyLoading = false;
            }
        }

        // Add scroll listener for lazy loading
        document.addEventListener('DOMContentLoaded', () => {
            const hList = document.getElementById('historyList');
            if (hList) {
                hList.addEventListener('scroll', () => {
                    if (hList.scrollTop + hList.clientHeight >= hList.scrollHeight - 60) {
                        if (hasMoreHistory && !historyLoading) {
                            loadHistory(true);
                        }
                    }
                });
            }
        });

        function renderHistory() {
            const historyList = document.getElementById('historyList');

            if (!historyList) return;

            // Note: If we are appending, we might not want to clear innerHTML.
            // But since our renderHistory clears it, it's safer for now or we update it to append.
            // Given vanilla JS, redraw is easier to maintain but slower. 
            // However, with metadata-only items, 100 items redraw is very fast.
            historyList.innerHTML = '';

            if (allHistory.length === 0) {
                historyList.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary); font-size: 13px;">暂无历史记录</div>';
                return;
            }

            allHistory.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'history-item';

                const date = new Date(item.timestamp || Date.now());
                const dateStr = `${date.getMonth() + 1}/${date.getDate()} ${date.getHours().toString().padStart(2, '0')}:${date.getMinutes().toString().padStart(2, '0')}`;

                const title = item.title || '未命名分析';
                const preview = item.preview || '';

                div.innerHTML = `
                    <div class="history-item-title">${title}</div>
                    <div class="history-item-meta">
                        <span>${dateStr}</span>
                        <span class="history-item-preview">${preview}...</span>
                    </div>
                `;

                div.addEventListener('click', async () => {
                    // Optimized: Fetch full detail only when clicked
                    let fullItem = item;
                    if (!item.result && !item.content) {
                        try {
                            showToast('正在加载详情...', 'info');
                            fullItem = await api.invoke('get-history-item', item.timestamp);
                            if (!fullItem) {
                                showToast('加载失败', 'error');
                                return;
                            }
                            // Update cache
                            allHistory[index] = fullItem;
                        } catch (err) {
                            showToast('加载详情出错', 'error');
                            return;
                        }
                    }
                    restoreHistoryItem(fullItem);
                });

                div.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    currentHistoryItem = item;
                    showHistoryContextMenu(e);
                });

                historyList.appendChild(div);
            });
        }

        function showHistoryContextMenu(e) {
            const menu = document.getElementById('historyContextMenu');
            if (!menu) return;

            menu.style.visibility = 'hidden';
            menu.classList.add('active');
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            menu.classList.remove('active');
            menu.style.visibility = 'visible';

            let x = e.clientX;
            let y = e.clientY;

            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;

            if (x + menuWidth > winWidth) x = winWidth - menuWidth - 5;
            if (y + menuHeight > winHeight) y = winHeight - menuHeight - 5;

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');

            // Close other menus
            document.querySelectorAll('.context-menu.active').forEach(m => {
                if (m !== menu) m.classList.remove('active');
            });
        }

        // History Context Menu Actions
        document.getElementById('ctxHistoryView')?.addEventListener('click', () => {
            if (currentHistoryItem) restoreHistoryItem(currentHistoryItem);
            document.getElementById('historyContextMenu').classList.remove('active');
        });

        document.getElementById('ctxHistoryDelete')?.addEventListener('click', () => {
            if (currentHistoryItem) {
                // Hide context menu first
                document.getElementById('historyContextMenu').classList.remove('active');

                showCustomModal({
                    title: '删除历史记录',
                    message: '确定要删除这条历史记录吗？此操作不可恢复。',
                    confirmText: '删除',
                    cancelText: '取消',
                    onConfirm: () => {
                        deleteHistoryItem(currentHistoryItem);
                    }
                });
            }
        });

        // Close context menu on click outside
        document.addEventListener('pointerdown', (e) => {
            const historyMenu = document.getElementById('historyContextMenu');
            if (historyMenu && historyMenu.classList.contains('active') && !historyMenu.contains(e.target)) {
                historyMenu.classList.remove('active');
            }

            const batchMenu = document.getElementById('batchContextMenu');
            if (batchMenu && batchMenu.classList.contains('active') && !batchMenu.contains(e.target)) {
                batchMenu.classList.remove('active');
            }
        });

        // Close on blur/resize like other menus
        window.addEventListener('blur', () => {
            const historyMenu = document.getElementById('historyContextMenu');
            if (historyMenu) historyMenu.classList.remove('active');

            const batchMenu = document.getElementById('batchContextMenu');
            if (batchMenu) batchMenu.classList.remove('active');
        });

        window.addEventListener('resize', () => {
            const historyMenu = document.getElementById('historyContextMenu');
            if (historyMenu) historyMenu.classList.remove('active');

            const batchMenu = document.getElementById('batchContextMenu');
            if (batchMenu) batchMenu.classList.remove('active');
        });

        async function deleteHistoryItem(item) {
            try {
                const response = await api.invoke('delete-history', item.timestamp);
                // In our mock, invoke returns result.data directly if success is true
                // But current delete-history in main.js returns {success: true}
                // Actually our mock throws if !result.success, so if it returns, it's successful.

                // Refresh list
                await loadHistory();
                showToast('已删除历史记录', 'success');
            } catch (err) {
                console.error('Failed to delete history:', err);
                showToast('删除失败', 'error');
            }
        }

        function restoreHistoryItem(item) {
            // Restore text input
            const textInput = document.getElementById('textInput');
            if (textInput) {
                // 优先使用 originalInput (新版逻辑)
                if (item.originalInput !== undefined) {
                    textInput.innerHTML = item.originalInput;
                } else {
                    // 兼容旧版逻辑
                    // Use innerText or textContent for contenteditable div
                    // If content is HTML, use innerHTML, otherwise textContent
                    if (item.isHtml) {
                        textInput.innerHTML = item.content;
                    } else {
                        textInput.innerText = item.content.replace(/<[^>]*>/g, '');
                    }
                }
                // Trigger input event to update word count etc.
                textInput.dispatchEvent(new Event('input'));
            }

            // Restore images in left panel
            // 如果原始输入是 URL，则不恢复图片到左侧编辑区域（因为这些图片通常是从网页提取的）
            const plainInput = (item.originalInput || "").replace(/<\/?[^>]+(>|$)/g, "").trim();
            const isUrl = isURL(plainInput);

            if (!isUrl && item.images && item.images.length > 0) {
                // Normalize images to match uploadedImages structure
                // 优化：恢复历史记录时使用代理 URL 以确保图片能正常加载并利用缓存
                uploadedImages = item.images.map(img => {
                    let url = (typeof img === 'string') ? img : img.url;
                    // 如果不是 Base64 或本地地址，则应用代理
                    if (url && url.startsWith('http') && !url.includes(window.location.origin)) {
                        url = getProxyUrl(url);
                    }
                    return {
                        id: (typeof img === 'object' && img.id) ? img.id : (Date.now() + Math.random()),
                        url: url,
                        name: (typeof img === 'object' && img.name) ? img.name : 'Restored Image'
                    };
                });
                renderImages();
            } else {
                uploadedImages = [];
                renderImages();
            }

            // Hide Initial State & Show Result Item
            const initialState = document.getElementById('initialState');
            const resultItem = document.getElementById('resultItem');
            const loadingState = document.getElementById('loadingState');

            if (loadingState) loadingState.classList.remove('active');
            if (initialState) {
                initialState.style.display = 'none';
                initialState.classList.remove('active'); // Just in case
            }

            if (resultItem) {
                resultItem.classList.add('active');
                resultItem.style.display = 'block'; // Ensure it's visible

                // Ensure Score and Analysis are visible
                const scoreSection = resultItem.querySelector('.result-score');
                const analysisSection = resultItem.querySelector('.result-analysis');
                if (scoreSection) scoreSection.style.display = 'flex';
                if (analysisSection) analysisSection.style.display = 'block';
            }

            // Show result content
            showAnalysisResult(item.result, item.content, item.images || [], item.isHtml || false);

            // Collapse sidebar on mobile
            if (window.innerWidth < 768) {
                toggleSidebar(false);
            }

            showToast('已恢复历史记录', 'success');
        }

        // Helper: Convert Blob URL to Base64
        async function blobUrlToBase64(blobUrl) {
            try {
                const response = await fetch(blobUrl);
                const blob = await response.blob();
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            } catch (e) {
                console.error("Blob conversion failed", e);
                return blobUrl;
            }
        }

        async function saveToHistory(content, result, images, isHtml, originalInputArg = null) {
            try {
                // 获取当前文本框的内容 (如果没有提供参数)
                let originalInput = originalInputArg;
                if (originalInput === null) {
                    const textInput = document.getElementById('textInput');
                    originalInput = textInput ? textInput.innerHTML : '';
                }

                // Process images for optimization and persistence
                // 优化逻辑：如果是Blob(本地图片)，转Base64保存；如果是Link(网络图片)，保存链接以节省空间
                let imagesToSave = [];
                if (images && Array.isArray(images)) {
                    imagesToSave = await Promise.all(images.map(async (img) => {
                        let url = (typeof img === 'string') ? img : img.url;

                        // If it's a local Blob URL, convert to Base64
                        if (url && url.startsWith('blob:')) {
                            const base64 = await blobUrlToBase64(url);
                            if (typeof img === 'string') return base64;
                            return { ...img, url: base64 };
                        }

                        // Keep HTTP/Data links as is
                        return img;
                    }));
                }

                const historyItem = {
                    content,
                    result,
                    images: imagesToSave,
                    isHtml,
                    originalInput, // 保存原始输入框内容
                    url: isURL(originalInput.replace(/<\/?[^>]+(>|$)/g, "").trim()) ? originalInput.replace(/<\/?[^>]+(>|$)/g, "").trim() : "",
                    timestamp: Date.now()
                };
                await api.invoke('save-history', historyItem);
                await loadHistory(); // Reload list
            } catch (err) {
                console.error('Failed to save history:', err);
            }
        }



        // Clear History Button Logic
        const clearHistoryBtn = document.getElementById('clearHistoryBtn');
        if (clearHistoryBtn) {
            clearHistoryBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                showCustomModal({
                    title: '清空历史记录',
                    message: '确定要删除所有历史记录吗？此操作不可恢复。',
                    confirmText: '清空',
                    cancelText: '取消',
                    onConfirm: async () => {
                        try {
                            await api.invoke('clear-history');
                            showToast('历史记录已清空', 'success');
                            loadHistory();
                        } catch (err) {
                            console.error(err);
                            showError('清空失败: ' + err.message);
                        }
                    }
                });
            });
        }

        // Initial load
        loadHistory();

        // 监听 initialState 的显示状态，控制 newChatBtn 的可用性
        (function () {
            const initialState = document.getElementById('initialState');
            const newChatBtn = document.getElementById('newChatBtn');

            if (initialState && newChatBtn) {
                const updateBtnState = () => {
                    const isVisible = getComputedStyle(initialState).display !== 'none';
                    newChatBtn.disabled = isVisible;
                    if (typeof updateClearButtonState === 'function') {
                        updateClearButtonState();
                    }
                };

                const observer = new MutationObserver((mutations) => {
                    mutations.forEach((mutation) => {
                        if (mutation.type === 'attributes' && (mutation.attributeName === 'style' || mutation.attributeName === 'class')) {
                            updateBtnState();
                        }
                    });
                });

                observer.observe(initialState, { attributes: true, attributeFilter: ['style', 'class'] });

                // 初始化检查
                // 使用 requestAnimationFrame 确保在下一帧渲染前执行，或者直接执行
                // 直接执行即可，因为脚本在底部
                updateBtnState();
            }
        })();

        // --- Batch Mode Logic ---
        let isBatchMode = false;
        let batchItems = []; // { id, content, images, result, progress, score }
        const MAX_BATCH_ITEMS = 200;
        let isBatchEditMode = false;
        let currentBatchEditId = null;
        let batchCounter = 1;

        const batchModeToggle = document.getElementById('batchModeToggle');
        const batchListContainer = document.getElementById('batchListContainer');
        const batchExitBtn = document.getElementById('batchExitBtn');
        const batchContextMenu = document.getElementById('batchContextMenu');
        let currentBatchContextId = null;

        // Toggle Batch Mode
        if (batchModeToggle) {
            batchModeToggle.addEventListener('click', () => {
                if (isBatchMode) {
                    // Check items
                    const validItems = batchItems.filter(item => item.content.trim() !== '' || (item.images && item.images.length > 0));

                    if (validItems.length === 0) {
                        // No valid items, exit directly
                        exitBatchMode();
                    } else if (validItems.length === 1) {
                        // Only one valid item, preserve it
                        const item = validItems[0];
                        exitBatchMode(false); // Pass false to NOT clear editor

                        // Restore content to editor
                        const textInput = document.getElementById('textInput');
                        if (textInput) {
                            textInput.innerText = item.content || '';
                            // Trigger input event to update word count etc.
                            textInput.dispatchEvent(new Event('input'));
                        }

                        if (item.images && item.images.length > 0) {
                            uploadedImages = item.images.map(img => {
                                if (typeof img === 'string') return { id: Date.now() + Math.random(), url: img, name: 'Image' };
                                return { ...img, id: img.id || (Date.now() + Math.random()) };
                            });
                            renderImages();
                        }

                        updateBtnState();
                        updateEditorStats();
                    } else {
                        // Multiple items, ask for confirmation
                        showCustomModal({
                            title: '退出批量模式',
                            message: '退出将清空当前批量列表中的所有内容，确定要退出吗？',
                            confirmText: '退出',
                            cancelText: '取消',
                            onConfirm: () => {
                                exitBatchMode();

                            }
                        });
                    }
                } else {
                    // Enter Batch Mode
                    enterBatchMode();
                }
            });
        }

        // Batch Toolbar Buttons
        const batchAddBtn = document.getElementById('batchAddBtn');
        if (batchAddBtn) {
            batchAddBtn.addEventListener('click', () => {
                const newId = addBatchItem('', []);
                renderBatchList();
                enterBatchEditMode(newId);
            });
        }

        const batchClearBtn = document.getElementById('batchClearBtn');
        if (batchClearBtn) {
            batchClearBtn.addEventListener('click', () => {
                if (batchItems.length === 0) return;
                showCustomModal({
                    title: '清空列表',
                    message: '确定要清空所有批量检测项吗？',
                    confirmText: '清空',
                    cancelText: '取消',
                    onConfirm: () => {
                        batchItems = [];
                        renderBatchList();
                        if (isBatchEditMode) {
                            isBatchEditMode = false;
                            currentBatchEditId = null;
                            document.body.classList.remove('batch-edit-mode');
                        }
                        // 同时重置右侧界面
                        resetRightPanel();
                    }
                });
            });
        }

        const batchFileBtn = document.getElementById('batchFileBtn');
        if (batchFileBtn) {
            // Remove previous listeners
            const newBatchBtn = batchFileBtn.cloneNode(true);
            batchFileBtn.parentNode.replaceChild(newBatchBtn, batchFileBtn);

            const batchInput = document.createElement('input');
            batchInput.type = 'file';
            batchInput.accept = '.txt,.md,.doc,.docx,.pdf,.xlsx,.xls';
            batchInput.multiple = true;
            batchInput.style.display = 'none';
            document.body.appendChild(batchInput);

            newBatchBtn.addEventListener('click', () => {
                batchInput.click();
            });

            batchInput.addEventListener('change', async (e) => {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                const sanitizeImportedImages = (imgs) => {
                    if (!Array.isArray(imgs)) return [];
                    return imgs.filter(img => {
                        if (typeof img !== 'string') return false;
                        const trimmed = img.trim();
                        if (trimmed.startsWith('data:image/')) return true;
                        return /^(http|https|file):\/\//i.test(trimmed);
                    });
                };

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const reader = new FileReader();
                    const promise = new Promise((resolve) => {
                        reader.onload = async (evt) => {
                            try {
                                showToast(`正在解析: ${file.name}...`, 'info');
                                const res = await api.invoke('process-file-upload', {
                                    name: file.name,
                                    data: evt.target.result.split(',')[1]
                                });

                                const { type, data } = res; // api.invoke returns res.data
                                const text = (data && data.text) || '';
                                // Note: If type is excel, data is array
                                if (type === 'excel') {
                                    if (Array.isArray(data)) {
                                        data.forEach(item => {
                                            addBatchItem(item.content, sanitizeImportedImages(item.images));
                                        });
                                    }
                                } else {
                                    const images = sanitizeImportedImages(data && data.images);
                                    addBatchItem(text, images);
                                }
                                resolve();
                            } catch (err) {
                                console.error(err);
                                showError(`解析 ${file.name} 失败: ` + err.message);
                                resolve();
                            }
                        };
                        reader.onerror = () => resolve();
                    });
                    reader.readAsDataURL(file);
                    await promise; // Process sequentially or parallel? Sequential safer for UI updates.
                }
                renderBatchList();
                batchInput.value = '';
            });
        }


        function enterBatchMode() {
            isBatchMode = true;
            document.body.classList.add('batch-mode-active');

            // Check for existing content
            const textInput = document.getElementById('textInput');
            const content = textInput.innerText.trim();
            const hasImages = uploadedImages.length > 0;

            batchItems = [];
            batchCounter = 1;

            if (content || hasImages) {
                addBatchItem(content, [...uploadedImages]);
                // Clear editor
                textInput.innerHTML = '';
                uploadedImages = [];
                renderImages();
                updateEditorStats();
            }

            renderBatchList();

            // Hide sidebar
            toggleSidebar(false);
        }

        function exitBatchMode(clearEditor = true) {
            isBatchMode = false;
            isBatchEditMode = false;
            currentBatchEditId = null;
            batchItems = [];

            document.body.classList.remove('batch-mode-active');
            document.body.classList.remove('batch-edit-mode');

            if (clearEditor) {
                clearEditorContent(false);
            }

            // Show sidebar
            // toggleSidebar(true); // Optional, maybe keep collapsed
        }

        function addBatchItem(content, images) {
            if (batchItems.length >= MAX_BATCH_ITEMS) {
                showToast(`批量列表最多支持 ${MAX_BATCH_ITEMS} 条，请先删除部分条目`, 'warning');
                return null;
            }
            const id = Date.now() + Math.random();
            batchItems.push({
                id,
                content: content || '',
                images: images || [],
                result: null,
                progress: 0,
                score: 0,
                status: 'idle' // idle, analyzing, done, error
            });
            return id;
        }

        function renderBatchList() {
            if (!batchListContainer) return;
            if (batchItems.length === 0) {
                batchListContainer.innerHTML = '';
                return;
            }

            // 1. Mark all existing items as stale
            const existingItems = new Map();
            Array.from(batchListContainer.children).forEach(el => {
                if (el.dataset.id) existingItems.set(el.dataset.id, el);
            });

            batchItems.forEach((item, index) => {
                let div = existingItems.get(String(item.id));
                const isNew = !div;

                if (isNew) {
                    div = document.createElement('div');
                    div.className = 'batch-item';
                    div.dataset.id = item.id;

                    // Events (only attach once)
                    div.addEventListener('click', () => {
                        if (item.result) {
                            const displayContent = item.parsedContent || item.content;
                            // Ensure images are in the correct format for showAnalysisResult
                            let displayImages = item.parsedImages || item.images;
                            if (displayImages && displayImages.length > 0 && typeof displayImages[0] === 'string') {
                                displayImages = displayImages.map(url => ({ url, name: 'Batch Image' }));
                            }
                            showAnalysisResult(item.result, displayContent, displayImages, false);
                        } else {
                            const resultItem = document.getElementById('resultItem');
                            const initialState = document.getElementById('initialState');
                            if (resultItem) resultItem.style.display = 'none';
                            if (initialState) initialState.style.display = 'flex';
                        }
                    });

                    div.addEventListener('dblclick', () => {
                        enterBatchEditMode(item.id);
                    });

                    div.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        currentBatchContextId = item.id;
                        showBatchContextMenu(e);
                    });

                    // Initial HTML structure
                    div.innerHTML = `
                        <div class="batch-item-index"></div>
                        <div class="batch-item-content">
                            <div class="batch-item-preview"></div>
                            <div class="batch-item-meta"></div>
                        </div>
                        <div class="batch-progress">
                            <svg viewBox="0 0 40 40">
                                <circle class="batch-progress-bg" cx="20" cy="20" r="16"></circle>
                                <circle class="batch-progress-value" cx="20" cy="20" r="16"></circle>
                            </svg>
                            <div class="batch-progress-text"></div>
                        </div>
                    `;

                    batchListContainer.appendChild(div);
                } else {
                    // Remove from stale map so we don't delete it
                    existingItems.delete(String(item.id));
                }

                // Update Content (Diffing)

                // Classes
                if (item.id === currentBatchEditId) div.classList.add('active');
                else div.classList.remove('active');

                if (item.status === 'skipped') div.classList.add('skipped');
                else div.classList.remove('skipped');

                // Text Content
                const contentToDisplay = item.parsedContent || item.content;
                const previewText = contentToDisplay
                    ? contentToDisplay.substring(0, 20) + (contentToDisplay.length > 20 ? '...' : '')
                    : ((item.images && item.images.length > 0) ? '[图片]' : '无内容');

                const indexEl = div.querySelector('.batch-item-index');
                if (indexEl.textContent !== `#${index + 1}`) indexEl.textContent = `#${index + 1}`;

                const previewEl = div.querySelector('.batch-item-preview');
                if (previewEl.textContent !== previewText) previewEl.textContent = previewText;

                let statusText = '未检测';
                if (item.status === 'done') statusText = `评分: ${item.score}%`;
                else if (item.status === 'analyzing') statusText = '检测中...';
                else if (item.status === 'skipped') statusText = '已跳过';
                else if (item.status === 'error') statusText = '错误';

                const metaEl = div.querySelector('.batch-item-meta');
                if (metaEl.textContent !== statusText) metaEl.textContent = statusText;

                // Progress Ring
                const radius = 16;
                const circumference = 2 * Math.PI * radius;

                let progressValue = 0;
                if (item.status === 'done') {
                    progressValue = item.score;
                } else if (item.status === 'analyzing') {
                    // Handled by CSS animation
                    progressValue = 0;
                } else {
                    progressValue = item.progress;
                }

                const offset = circumference - (progressValue / 100) * circumference;
                const isAnalyzing = item.status === 'analyzing';

                const progressContainer = div.querySelector('.batch-progress');
                const svg = div.querySelector('svg');

                if (svg.classList.contains('rotating')) svg.classList.remove('rotating');
                if (svg.classList.contains('analyzing')) svg.classList.remove('analyzing');

                if (isAnalyzing) {
                    progressContainer.classList.add('loading');
                } else {
                    progressContainer.classList.remove('loading');
                }

                const progressCircle = div.querySelector('.batch-progress-value');

                // Only update styles via JS if NOT analyzing (CSS handles analyzing state)
                if (!isAnalyzing) {
                    // Use cached state to prevent DOM thrashing
                    const lastState = div._lastState || {};
                    const newState = {
                        dashArray: circumference,
                        dashOffset: offset,
                        stroke: getScoreColor(item.score)
                    };

                    // Only update DOM if values actually changed
                    if (lastState.dashArray !== newState.dashArray) {
                        progressCircle.style.strokeDasharray = `${newState.dashArray}`;
                    }
                    if (lastState.dashOffset !== newState.dashOffset) {
                        progressCircle.style.strokeDashoffset = `${newState.dashOffset}`;
                    }
                    if (lastState.stroke !== newState.stroke) {
                        progressCircle.style.stroke = newState.stroke;
                    }

                    // Update cache
                    div._lastState = newState;
                }

                const progressText = div.querySelector('.batch-progress-text');
                if (isAnalyzing) {
                    if (progressText.textContent !== '') progressText.textContent = '';
                } else if (progressText.textContent !== String(item.score)) {
                    progressText.textContent = item.score;
                }
            });

            // Remove stale items
            existingItems.forEach(el => el.remove());
        }

        function getScoreColor(score) {
            if (score >= 80) return 'var(--success-color)';
            if (score >= 60) return 'var(--warning-color)';
            return 'var(--danger-color)';
        }

        function showBatchContextMenu(e) {
            const menu = document.getElementById('batchContextMenu');
            if (!menu) return;

            menu.style.visibility = 'hidden';
            menu.classList.add('active');
            const menuWidth = menu.offsetWidth;
            const menuHeight = menu.offsetHeight;
            menu.classList.remove('active');
            menu.style.visibility = 'visible';

            let x = e.clientX;
            let y = e.clientY;

            const winWidth = window.innerWidth;
            const winHeight = window.innerHeight;

            if (x + menuWidth > winWidth) x = winWidth - menuWidth - 5;
            if (y + menuHeight > winHeight) y = winHeight - menuHeight - 5;

            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('active');

            // Close other menus
            document.querySelectorAll('.context-menu.active').forEach(m => {
                if (m !== menu) m.classList.remove('active');
            });
        }

        // Batch Context Menu Actions
        document.getElementById('ctxBatchEdit')?.addEventListener('click', () => {
            if (currentBatchContextId) enterBatchEditMode(currentBatchContextId);
            document.getElementById('batchContextMenu').classList.remove('active');
        });

        document.getElementById('ctxBatchView')?.addEventListener('click', () => {
            const item = batchItems.find(i => i.id === currentBatchContextId);
            if (item && item.result) {
                const displayContent = item.parsedContent || item.content;
                // Ensure images are in the correct format for showAnalysisResult
                let displayImages = item.parsedImages || item.images;
                if (displayImages && displayImages.length > 0 && typeof displayImages[0] === 'string') {
                    displayImages = displayImages.map(url => ({ url, name: 'Batch Image' }));
                }
                showAnalysisResult(item.result, displayContent, displayImages, false);
            }
            document.getElementById('batchContextMenu').classList.remove('active');
        });

        document.getElementById('ctxBatchDelete')?.addEventListener('click', () => {
            if (currentBatchContextId) {
                batchItems = batchItems.filter(i => i.id !== currentBatchContextId);
                renderBatchList();
            }
            document.getElementById('batchContextMenu').classList.remove('active');
        });

        function formatSearchResultsForHistory(result) {
            // 如果结果中有 search_results，保留它
            if (result.search_results) {
                return result.search_results;
            }
            return null;
        }

        function enterBatchEditMode(id) {
            const item = batchItems.find(i => i.id === id);
            if (!item) return;

            currentBatchEditId = id;
            isBatchEditMode = true;
            document.body.classList.add('batch-edit-mode');

            // Restore content to editor
            const textInput = document.getElementById('textInput');
            textInput.innerText = item.content; // Or innerHTML if we support rich text

            // Convert stored image strings back to editor objects
            uploadedImages = (item.images || []).map(img => {
                if (typeof img === 'string') {
                    return {
                        id: Date.now() + Math.random(),
                        url: img,
                        name: 'Batch Image',
                        file: null
                    };
                }
                return img; // Fallback for legacy objects
            });

            renderImages();
            updateEditorStats();

            // Show sidebar
            // toggleSidebar(true); // Disabled per request
        }

        // Exit Batch Edit Button Logic
        if (batchExitBtn) {
            batchExitBtn.addEventListener('click', () => {
                saveBatchItem();

                // Cleanup empty items: Keep at most one empty item
                const newBatchItems = [];
                let hasEmpty = false;

                for (const item of batchItems) {
                    const isEmpty = !item.content && (!item.images || item.images.length === 0);
                    if (isEmpty) {
                        if (!hasEmpty) {
                            newBatchItems.push(item);
                            hasEmpty = true;
                        }
                        // else skip subsequent empty items
                    } else {
                        newBatchItems.push(item);
                    }
                }
                batchItems = newBatchItems;

                isBatchEditMode = false;
                currentBatchEditId = null;
                document.body.classList.remove('batch-edit-mode');
                toggleSidebar(false); // Hide sidebar when returning to list
                renderBatchList();
            });
        }

        function saveBatchItem() {
            if (!currentBatchEditId) return;
            const item = batchItems.find(i => i.id === currentBatchEditId);
            if (item) {
                const textInput = document.getElementById('textInput');
                item.content = textInput.innerText.trim();
                // Convert editor objects back to image strings
                item.images = uploadedImages.map(img => img.url);
            }
        }

        async function startBatchDetection() {
            const detectBtn = document.getElementById('detectBtn');
            if (detectBtn.classList.contains('loading')) return;

            detectBtn.classList.add('loading');
            detectBtn.innerHTML = '批量检测中...';
            detectBtn.disabled = true;

            // Calculate total progress
            const totalItems = batchItems.length;
            let processedItems = 0;

            for (let i = 0; i < totalItems; i++) {
                const item = batchItems[i];

                // Skip empty items
                if (!item.content && (!item.images || item.images.length === 0)) {
                    item.status = 'skipped';
                    continue;
                }

                if (item.status === 'done') {
                    processedItems++;
                    continue;
                }

                item.status = 'analyzing';
                renderBatchList(); // Update UI to show "analyzing"

                try {
                    let imageUrls = [];
                    if (item.images && item.images.length > 0) {
                        imageUrls = item.images.slice(0, 4).map(img => typeof img === 'string' ? img : img.url);
                    }

                    let sourceUrl = '';
                    if (isURL(item.content)) {
                        sourceUrl = item.content;
                    }

                    // Simulate progress for item
                    let itemProgress = 0;
                    const progressInterval = setInterval(() => {
                        if (itemProgress < 90) {
                            itemProgress += 5;
                            item.progress = itemProgress;
                            renderBatchList(); // Re-render to show progress
                        }
                    }, 200);

                    let analysisResult;

                    // If it's a URL, extract content first
                    if (sourceUrl) {
                        try {
                            // Call extract-content
                            const extractRes = await api.invoke('extract-content-sync', sourceUrl);
                            // extractRes is already extractRes.data

                            // Use extracted content for analysis
                            const extractedText = extractRes.textContent || extractRes.content;
                            const extractedImages = extractRes.images || [];

                            // Store parsed content in item for display
                            item.parsedContent = extractedText;
                            item.parsedImages = extractedImages;

                            // Analyze extracted content
                            const response = await api.invoke('analyze-content', {
                                text: extractedText,
                                imageUrls: extractedImages,
                                url: sourceUrl
                            });
                            analysisResult = response;
                        } catch (e) {
                            analysisResult = {
            "status": "fail",
            "code": 400,
            "message": e.message,
            "data": {},
            "error": {}
        };
                        }
                    } else {
                        // Normal analysis
                        const response = await api.invoke('analyze-content', {
                            text: item.content,
                            imageUrls,
                            url: sourceUrl
                        });
                        analysisResult = response;
                    }

                    clearInterval(progressInterval);

                    if (analysisResult && (analysisResult.status !== 'fail' || analysisResult.probability !== undefined)) {
                        // Normalize result - handle nested data or flat object
                        item.result = analysisResult.data || analysisResult;
                        const fakeProb = item.result.probability || 0;
                        item.score = Math.round(fakeProb * 100);
                        item.status = 'done';
                        item.progress = 100;

                        // Save to history
                        const contentToSave = item.parsedContent || item.content;
                        const imagesToSave = item.parsedImages || item.images;

                        // 批量模式也记录原始输入 (通常是 URL 或 文本)
                        await saveToHistory(contentToSave, item.result, imagesToSave, false, item.content);
                    } else {
                        item.status = 'error';
                        item.progress = 0;
                        console.error(analysisResult ? (analysisResult.message || '分析失败') : '无响应');
                    }
                } catch (err) {
                    console.error(err);
                    item.status = 'error';
                    item.progress = 0;
                }

                processedItems++;
                renderBatchList();
                // Update total progress on button
                detectBtn.innerHTML = `批量检测中 (${processedItems}/${totalItems})`;
            }

            detectBtn.classList.remove('loading');
            detectBtn.innerHTML = '开始检测';
            detectBtn.disabled = false;
            showToast('批量检测完成', 'success');
        }


        // --- Color Palette Logic ---
        async function initColorPalette() {
            const container = document.getElementById('colorPaletteContainer');
            if (!container) return;

            try {
                // Fetch public presets and user prefs
                const [presetsRes, prefsRes] = await Promise.all([
                    fetch('/api/public/presets').then(r => r.json()),
                    fetch('/api/user/preferences').then(r => r.json())
                ]);

                const presets = presetsRes.status !== 'fail' ? presetsRes.data : [];
                // Allow "0" or null to mean default
                const userThemeId = (prefsRes.status !== 'fail' && prefsRes.preferences && prefsRes.preferences.themeId) ? prefsRes.preferences.themeId : 0;

                container.innerHTML = '';

                // 1. Default (White/Server) Button
                const defaultBtn = document.createElement('div');
                defaultBtn.className = `color-circle-btn server-default ${!userThemeId ? 'active' : ''}`;
                defaultBtn.title = "默认";
                defaultBtn.onclick = () => applyThemePreference(0);
                container.appendChild(defaultBtn);

                // 2. Preset Buttons
                presets.forEach(p => {
                    const btn = document.createElement('div');
                    // Check strict equality or loose equality for ID
                    const isActive = userThemeId == p.id;
                    btn.className = `color-circle-btn ${isActive ? 'active' : ''}`;
                    btn.title = p.title;
                    if (p.colors && p.colors.length > 0) {
                        btn.style.backgroundColor = p.colors[0]; // Primary color
                    }
                    btn.onclick = () => applyThemePreference(p.id);
                    container.appendChild(btn);
                });

            } catch (e) {
                console.error("Failed to init color palette", e);
            }
        }

        async function applyThemePreference(themeId) {
            try {
                const res = await fetch('/api/user/preferences', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ themeId: themeId })
                });
                const data = await res.json();

                if (data.status !== 'fail') {
                    // Reload theme from server (which now respects user pref)
                    if (window.applyDynamicTheme) {
                        await window.applyDynamicTheme(true);
                    }
                    // Updates active class
                    initColorPalette();
                    showToast('主题已更新', 'success');
                }
            } catch (e) {
                showToast('保存设置失败', 'error');
            }
        }

        // Initialize Palette
        document.addEventListener('DOMContentLoaded', () => {
            initColorPalette();
        });

    </script>
</body>

</html>